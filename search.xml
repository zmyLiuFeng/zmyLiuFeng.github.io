<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[本机无密码连接linux上非root用户]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%9C%AC%E6%9C%BA%E6%97%A0%E5%AF%86%E7%A0%81%E8%BF%9E%E6%8E%A5linux%E4%B8%8A%E9%9D%9Eroot%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈集合]]></title>
    <url>%2F2018%2F11%2F21%2F%E6%B5%85%E8%B0%88%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Collection Collection是一个接口，他定义了集合的基本方法，比如添加，删除等等，他最主要有两个分支，List和SetList 和 Set 都是接口，他们都继承了 Collection接口，不同的是 List 是有序的队列，允许存储相同的元素，而 Set 是数学概念上的集合，不允许存储相同的元素List 和 Set都有他们的实现类 为了方便 我们抽象出了 AbstractCollection 抽象类，他实现了Collection 中的绝大部分接口，这样 Collection 的实现类就可以直接继承 AbstractCollection而省去重复编码，AbstractList 和 AbstractSet 都继承了 AbstractCollection,不同的是，具体 List 的实现类继承了 AbstractList，Set 的实现类继承了 AbstractSet 1 Collection简介Collection的定义如下： public interface Collection extends Iterable {}它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。 Collection接口的所有子类(直接子类和间接子类)都必须实现2种构造函数：不带参数的构造函数 和 参数为Collection的构造函数。带参数的构造函数，可以用来转换Collection的类型。 复制代码// Collection的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract T[] toArray(T[] array)abstract Object[] toArray()复制代码 2 List简介List的定义如下： public interface List extends Collection {}List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。List的官方介绍如下： A List is a collection which maintains an ordering for its elements. Every element in the List has an index. Each element can thus be accessed by its index, with the first index being zero. Normally, Lists allow duplicate elements, as compared to Sets, where elements have to be unique. 关于API方面。既然List是继承于Collection接口，它自然就包含了Collection中的全部函数接口；由于List是有序队列，它也额外的有自己的API接口。主要有“添加、删除、获取、修改指定位置的元素”、“获取List中的子队列”等。 复制代码// Collection的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract T[] toArray(T[] array)abstract Object[] toArray()// 相比与Collection，List新增的API：abstract void add(int location, E object)abstract boolean addAll(int location, Collection&lt;? extends E&gt; collection)abstract E get(int location)abstract int indexOf(Object object)abstract int lastIndexOf(Object object)abstract ListIterator listIterator(int location)abstract ListIterator listIterator()abstract E remove(int location)abstract E set(int location, E object)abstract List subList(int start, int end)复制代码 3 Set简介Set的定义如下： public interface Set extends Collection {}Set是一个继承于Collection的接口，即Set也是集合中的一种。Set是没有重复元素的集合。 关于API方面。Set的API和Collection完全一样。 复制代码// Set的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract T[] toArray(T[] array)abstract Object[] toArray()复制代码 4 AbstractCollectionAbstractCollection的定义如下： public abstract class AbstractCollection implements Collection {}AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。AbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。 5 AbstractListAbstractList的定义如下： public abstract class AbstractList extends AbstractCollection implements List {}AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。AbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。 6 AbstractSetAbstractSet的定义如下： public abstract class AbstractSet extends AbstractCollection implements Set {}AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。AbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。 7 IteratorIterator的定义如下： public interface Iterator {}Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。注意：Iterator遍历Collection时，是fail-fast机制的。即，当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。关于fail-fast的详细内容，我们会在后面专门进行说明。TODO // Iterator的APIabstract boolean hasNext()abstract E next()abstract void remove() 8 ListIteratorListIterator的定义如下： public interface ListIterator extends Iterator {}ListIterator是一个继承于Iterator的接口，它是队列迭代器。专门用于便利List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等API接口。 复制代码// ListIterator的API// 继承于Iterator的接口abstract boolean hasNext()abstract E next()abstract void remove()// 新增API接口abstract void add(E object)abstract boolean hasPrevious()abstract int nextIndex()abstract E previous()abstract int previousIndex()abstract void set(E object)复制代码 (不相同的地方只是为了记忆而重新码的)转载自: http://www.cnblogs.com/skywang12345/p/3308513.html]]></content>
      <categories>
        <category>面试纪要</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashMap]]></title>
    <url>%2F2018%2F11%2F21%2FhashMap%2F</url>
    <content type="text"><![CDATA[什么是 HashMap？HashMap 是一个用于存储键值对（key-value）的集合，他是基于哈希表实现的，他内部的通过单项链表来解决冲突问题，hashMap 是线程不安全的，concurrent 并发包下的 concurrentHashMap 是线程安全的hashMap实现了 Serializable接口，因此他可以被序列化，实现了 Cloneable 接口因此可以被克隆 HashMap存数据的过程HashMap 内部维护了一个存储数据的 Entry数组，他通过链表来解决冲突，每一个 Entry 本质上都是一个单向链表，当准备添加一个（key-value）时，先通过 Hash(key)计算 hash 值，然后通过 indexFor(hash,length) 求取存储位置，计算方法是先用hash&amp;0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出来的位置相同时，由于存入的位置是一个链表，则把这个 key-value 存入链表头。hashMap 的 key-value 都可以为null，但是 key 为 null的键值对，永远存放在 table[0]为头结点的链表中。了解了数据的存储，那么数据的读取也就很容易就明白了。 HashMap的存储结构，如下图所示： 图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。 hashMap 的扩容HashMap内存储数据的Entry数组默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了HashMap的存储意义了。所以HasnMap内部有自己的扩容机制。HashMap内部有：变量size，它记录HashMap的底层数组中已用槽的数量；变量threshold，它是HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）变量DEFAULT_LOAD_FACTOR = 0.75f，默认加载因子为0.75 HashMap扩容的条件是：当size大于threshold时，对HashMap进行扩容扩容是是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。 HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。 下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。 另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方 最后总结hashMap是一个存储 key-value 的集合，其内部维护了一个存储数据的 Entry 数组，每个 Entry 本质上是一个单项列表，hashMap不是线程安全的，他可以被序列化，也可以被克隆，他扩容非常耗费资源，因为其扩容的时候，新建了一个数组，然后对重新计算所有元素在新的数组中的索引位置，然后再添加到扩容后新的数组中]]></content>
      <categories>
        <category>面试纪要</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashCode() 和equals()]]></title>
    <url>%2F2018%2F11%2F21%2FheshCode-%E5%92%8Cequals%2F</url>
    <content type="text"><![CDATA[在这里我们首先要知道什么是对象，什么是对象的引用？到底什么是对象，什么是对象的引用？对象和对象的引用有那些区别？一、分析对象引用与对象的区别为了接下来进行更好的分析，我先建立一个Demo类，用于后面的分析。 public class Demo{ //默认构造方法 public Demo{ }接下来，我们用Demo类来创建一个对象。 Demo demo=new Demo();这一条语句，其实包括了四个动作：1）右边的“new Demo”，是以Demo类为模板，在堆空间里创建一个Demo对象。2）末尾的()意味着，在对象创建后，立即调用Demo类的构造函数，对刚生成的对象进行初始化。3）左边的“Demo demo”创建了一个Demo类引用变量，它存放在栈空间中。也就是用来指向Demo对象的对象引用。4）“=”操作符使对象引用指向刚创建的那个Demo对象。 当然这条语句我们也可以写成：Demo demo;//创建对象引用demo=/将对象引用指向对象/new Demo();//创建对象 这样显得更加清晰了。 二、对象引用与对象之间的关系1）从对象引用出发:一个对象引用可以指向一个对象Demo demo；//一个对象引用demo=new Demo();//一个对象引用指向一个对象也可以被多个对象引用同时引用。 Demo demo1，demo2，demo3;//创建多个对象引用demo1=new Demo();demo2=demo1;demo3=demo2;//创建对象，并被多个对象引用指向 equalsequals()：反映的是对象或变量具体的值，即两个对象里面包含的值–可能是对象的引用，也可能是值类型的值。 hashCodehashCode()：计算出对象实例的哈希码，并返回哈希码，又称为散列函数。根类Object的hashCode()方法的计算依赖于对象实例的D（内存地址），故每个Object对象的hashCode都是唯一的；当然，当对象所对应的类重写了hashCode()方法时，结果就截然不同了。 两相比较之所以有hashCode方法，是因为在批量的对象比较中，hashCode要比equals来得快，很多集合都用到了hashCode，比如HashTable。 两个obj，如果equals()相等，hashCode()一定相等。 两个obj，如果hashCode()相等，equals()不一定相等（Hash散列值有冲突的情况，虽然概率很低）。所以： 可以考虑在集合中，判断两个对象是否相等的规则是： 第一步，如果hashCode()相等，则查看第二步，否则不相等; 第二步，查看equals()是否相等，如果相等，则两obj相等，否则还是不相等。 1、首先equals()和hashcode()这两个方法都是从object类中继承过来的。 equals()是对两个对象的地址值进行的比较（即比较引用是否相同）。 hashCode()是一个本地方法，它的实现是根据本地机器相关的。 2、Java语言对equals()的要求如下，这些要求是必须遵循的： A 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 B 反射性：x.equals(x)必须返回是“true”。 C 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 D 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 3、equals()相等的两个对象，hashcode()一定相等； 反过来：hashcode()不等，一定能推出equals()也不等； hashcode()相等，equals()可能相等，也可能不等。 为什么选择hashcode方法？ 以java.lang.Object来理解,JVM每new一个Object,它都会将这个Object丢到一个Hash哈希表中去,这样的话,下次做Object的比较或者取这个对象的时候,它会根据对象的hashcode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。具体过程是这样: new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。 比较两个对象的时候,首先根据他们的hashcode去hash表中找他的对象,当两个对象的hashcode相同,那么就是说他们这两个对象放在Hash表中的同一个key上,那么他们一定在这个key上的链表上。那么此时就只能根据Object的equal方法来比较这个对象是否equal。当两个对象的hashcode不同的话，肯定他们不能equal. 可能经过上面理论的讲一下大家都迷糊了，我也看了之后也是似懂非懂的。下面我举个例子详细说明下。 list是可以重复的，set是不可以重复的。那么set存储数据的时候是怎样判断存进的数据是否已经存在。使用equals()方法呢，还是hashcode()方法。 假如用equals()，那么存储一个元素就要跟已存在的所有元素比较一遍，比如已存入100个元素，那么存101个元素的时候，就要调用equals方法100次。 但如果用hashcode()方法的话，他就利用了hash算法来存储数据的。 这样的话每存一个数据就调用一次hashcode()方法，得到一个hashcode值及存入的位置。如果该位置不存在数据那么就直接存入，否则调用一次equals()方法，不相同则存，相同不存。这样下来整个存储下来不需要调用几次equals方法，虽然多了几次hashcode方法，但相对于前面来讲效率高了不少。 为什么要重写equals方法？ 因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存,地址则相等，否则不相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。 说道这个地方我相信很多人会有疑问，相信大家都被String对象的equals()方法和”==”纠结过一段时间，当时我们知道String对象中equals方法是判断值的，而==是地址判断。 那照这么说equals怎么会是地址的比较呢？ 那是因为实际上JDK中，String、Math等封装类都对Object中的equals()方法进行了重写。 我们先看看Object中equals方法的源码： 123public boolean equals(Object obj) { return (this == obj);}我们都知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，所以才会有String这些类对equals方法的改写，依次类推Double、Integer、Math。。。。等等这些类都是重写了equals()方法的，从而进行的是内容的比较。希望大家不要搞混了。 改写equals时总是要改写hashcode java.lnag.Object中对hashCode的约定： 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。 根据上一个问题，实际上我们已经能很简单的解释这一点了，比如改写String中的equals为基于内容上的比较而不是内存地址的话，那么虽然equals相等，但并不代表内存地址相等，由hashcode方法的定义可知内存地址不同，没改写的hashcode值也可能不同。所以违背了第二条约定。 又如new一个对象，再new一个内容相等的对象，调用equals方法返回的true，但他们的hashcode值不同，将两个对象存入HashSet中，会使得其中包含两个相等的对象，因为是先检索hashcode值，不等的情况下才会去比较equals方法的。 hashCode方法使用介绍 Hash表数据结构常识： 一、哈希表基于数组。 二、缺点：基于数组的，数组创建后难以扩展。某些哈希表被基本填满时，性能下降得非常严重。 三、没有一种简便得方法可以以任何一种顺序遍历表中数据项。 四、如果不需要有序遍历数据，并且可以提前预测数据量的大小，那么哈希表在速度和易用性方面是无与伦比的。 一、为什么HashCode对于对象是如此的重要： 一个对象的HashCode就是一个简单的Hash算法的实现，虽然它和那些真正的复杂的Hash算法相比还不能叫真正的算法，它如何实现它，不仅仅是程序员的编程水平问题， 而是关系到你的对象在存取是性能的非常重要的关系.有可能，不同的HashCode可能会使你的对象存取产生，成百上千倍的性能差别. 先来看一下，在JAVA中两个重要的数据结构:HashMap和Hashtable，虽然它们有很大的区别，如继承关系不同，对value的约束条件(是否允许null)不同，以及线程安全性等有着特定的区别，但从实现原理上来说，它们是一致的.所以，我们只以Hashtable来说明： 在java中，存取数据的性能，一般来说当然是首推数组，但是在数据量稍大的容器选择中，Hashtable将有比数组性能更高的查询速度.具体原因看下面的内容. Hashtable在存储数据时，一般先将该对象的HashCode和0x7FFFFFFF做与操作，因为一个对象的HashCode可以为负数，这样操作后可以保证它为一个正整数.然后以Hashtable的长度取模，得到该对象在Hashtable中的索引. index = (o.hashCode() &amp; 0x7FFFFFFF)%hs.length; 这个对象就会直接放在Hashtable的每index位置，对于写入，这和数组一样，把一个对象放在其中的第index位置，但如果是查询，经过同样的算法，Hashtable可以直接从第index取得这个对象，而数组却要做循环比较.所以对于数据量稍大时，Hashtable的查询比数组具有更高的性能. 既然一个对象可以根据HashCode直接定位它在Hashtable中的位置，那么为什么Hashtable还要用key来做映射呢?这就是关系Hashtable性能问题的最重要的问题：Hash冲突. 常见的Hash冲突是不同对象最终产生了相同的索引，而一种非常甚至绝对少见的Hash冲突是，如果一组对象的个数大过了int范围，而HashCode的长度只能在int范围中，所以肯定要有同一组的元素有相同的HashCode，这样无论如何他们都会有相同的索引.当然这种极端的情况是极少见的，可以暂不考虑，但是对于同的HashCode经过取模，则会产中相同的索引，或者不同的对象却具有相同的HashCode，当然具有相同的索引. 所以对于索引相同的对象，在该index位置存放了多个值，这些值要想能正确区分，就要依靠key来识别. 事实上一个设计各好的HashTable，一般来说会比较平均地分布每个元素，因为Hashtable的长度总是比实际元素的个数按一定比例进行自增(装填因子一般为0.75)左右，这样大多数的索引位置只有一个对象，而很少的位置会有几个元素.所以Hashtable中的每个位置存放的是一个链表，对于只有一个对象是位置，链表只有一个首节点(Entry)，Entry的next为null.然后有hashCode，key，value属性保存了该位置的对象的HashCode，key和value(对象本身)，如果有相同索引的对象进来则会进入链表的下一个节点.如果同一个索引中有多个对象，根据HashCode和key可以在该链表中找到一个和查询的key相匹配的对象.从上面我看可以看到，对于HashMap和Hashtable的存取性能有重大影响的首先是应该使该数据结构中的元素尽量大可能具有不同的HashCode，虽然这并不能保证不同的HashCode产生不同的index，但相同的HashCode一定产生相同的index，从而影响产生Hash冲突. 对于一个象，如果具有很多属性，把所有属性都参与散列，显然是一种笨拙的设计.因为对象的HashCode()方法几乎无所不在地被自动调用，如equals比较，如果太多的对象参与了散列.那么需要的操作常数时间将会增加很大.所以，挑选哪些属性参与散列绝对是一个编程水平的问题.从实现来说，一般的HashCode方法会这样: return Attribute1.HashCode() Attribute1.HashCode()..[ super.HashCode()]，我们知道，每次调用这个方法，都要重新对方法内的参与散列的对象重新计算一次它们的HashCode的运算，如果一个对象的属性没有改变，仍然要每次都进行计算，所以如果设置一个标记来缓存当前的散列码，只要当参与散列的对象改变时才重新计算，否则调用缓存的hashCode，这可以从很大程度上提高性能.默认的实现是将对象内部地址转化为整数作为HashCode，这当然能保证每个对象具有不同的HasCode，因为不同的对象内部地址肯定不同(废话)，但java语言并不能让程序员获取对象内部地址，所以，让每个对象产生不同的HashCode有着很多可研究的技术. 如果从多个属性中采样出能具有平均分布的hashCode的属性，这是一个性能和多样性相矛盾的地方，如果所有属性都参与散列，当然hashCode的多样性将大大提高，但牺牲了性能，而如果只能少量的属性采样散列，极端情况会产生大量的散列冲突，如对”人”的属性中，如果用性别而不是姓名或出生日期，那将只有两个或几个可选的hashcode值，将产生一半以上的散列冲突.所以如果可能的条件下，专门产生一个序列用来生成HashCode将是一个好的选择(当然产生序列的性能要比所有属性参与散列的性能高的情况下才行，否则还不如直接用所有属性散列).如何对HashCode的性能和多样性求得一个平衡，可以参考相关算法设计的书，其实并不一定要求非常的优秀，只要能尽最大可能减少散列值的聚集.重要的是我们应该记得HashCode对于我们的程序性能有着重要的影响，在程序设计时应该时时加以注意. 请记住：如果你想有效的使用HashMap，你就必须重写在其的HashCode()。还有两条重写HashCode()的原则：不必对每个不同的对象都产生一个唯一的hashcode，只要你的HashCode方法使get()能够得到put()放进去的内容就可以了。即“不为一原则”。生成hashcode的算法尽量使hashcode的值分散一些， 不要很多hashcode都集中在一个范围内，这样有利于提高HashMap的性能。即“分散原则”。 掌握了这两条原则，你就能够用好HashMap编写自己的程序了。不知道大家注意没有， java.lang.Object中提供的三个方法：clone()，equals()和hashCode()虽然很典型，但在很多情况下都不能够适用，它们只是简单的由对象的地址得出结果。这就需要我们在自己的程序中重写它们，其实java类库中也重写了千千万万个这样的方法。利用面向对象的多态性——覆盖，Java的设计者很优雅的构建了Java的结构，也更加体现了Java是一门纯OOP语言的特性。 Java提供的Collection和Map的功能是十分强大的，它们能够使你的程序实现方式更为灵活，执行效率更高。希望本文能够对大家更好的使用HashMap有所帮助。]]></content>
      <categories>
        <category>面试纪要</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Java,Tomcat-Server中Time和服务器中不一致]]></title>
    <url>%2F2018%2F11%2F20%2FLinux%20Java%2CTomcat-Server%E4%B8%ADTime%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E4%B8%8D%E4%B8%80%E8%87%B4%2F</url>
    <content type="text"><![CDATA[今天在测试任务调度过程中，发现已经到时间了，结果任务调度还是不执行，因为在代码中取得时间是 new Date(),于是排查服务器的时间 Fri Nov 25 11:29:31 CST 2018 是正确的，又排查 java 的时间 Fri Nov 25 11:29:31 CST 2018 也是正确，在 tomcat 容器中运行一个 jsp 打印了一下时间 Fri Nov 25 04:43:51 GMT 2018 发现少了8小时 明显jsp中打印的时间时区为GMT CET,UTC,GMT,CST几种常见时间概述与关系 已经过以上测试，可能是Tomcat问题，那么修改tomcat 启动参数http: //free.yes81.net/yes81/view-13576.html 按照以上方式修改后，tomcat内Date时间正常 过程中还发现一个问题我的系统中 /etc/sysconfig/clock 文件只有一行（文件说明） ZONE=”Asia/Shanghai”并没有这两行。 UTC=falseARC=false加上后，tomcat不修改时间也是正常。 后经过搜索返现一篇博文http: //blog.tangjianwei.com/2009/06/04/the-problem-of-tomcat-timezone/启动提到：tomcat读取的可能是硬件时间（BIOS时间）而UTC=falseUTC – 指定BIOS中保存的时间是否是GMT/UTC时间，true表示BIOS里面保存的时间是UTC时间，false表示BIOS里面保存的时间是本地时间。 所以判断 可能为之前没有设置 /etc/sysconfig/clock 中 UTC=false，倒置tomcat读取时区出现问题倒置。 到此问题基本解决。 其他相关博文http: //escode.blog.51cto.com/2025829/1147439 转载 原文地址 https: //www.cnblogs.com/weihuang6620/p/9268880.html]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行与并发]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[并行与并发并发和并行最开始都是操作系统中的概念，表示的是CPU执行多个任务的方式。这两个概念极容易混淆。 并行1.什么是并行？并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。 (只有在系统有多个 CPU 的时候才会出现真正意义上的并行)多个人同事做多件事 并发1.什么是并发？并发实际就是 cpu 时间片的切换，在单核 CPU 中，CPU同一时间内只能做一件事情，Windown 系统为了让其看起来是“同时做多件事请”，把 CPU 的时间划划分长短基本相同的时间区间，既“时间片”，通过操作系统的管理，把这些时间片进行轮流的分配给各个应用使用，这样，给用户的感觉就是他在同时进行听歌和打游戏，实际上，在操作系统中，CPU 是在听歌进程和游戏进程中来回快速的切换。这个是我们所理解的并发，那么并发的定义到底是什么呢？并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。一个人同事做多件事 并行和并发的区别并发，指的是多个事情，在同一时间段内同时发生了。并行，指的是多个事情，在同一时间点上同时发生了。 并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的、 只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。 就像上面这张图，只有一个咖啡机的时候，一台咖啡机其实是在并发被使用的。而有多个咖啡机的时候，多个咖啡机之间才是并行被使用的。]]></content>
      <categories>
        <category>阅读理解</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下Docker的安装使用]]></title>
    <url>%2F2018%2F10%2F17%2FMac%E4%B8%8BDocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Mac下Docker的安装使用1.什么是 dockerDocker，可以说是一个终端命令行的虚拟机，但更准确的说法，其实应该是一个虚拟环境。比如，你想要在PC上无缝使用Linux么？那么虚拟机并不是你唯一的出路，你还有Docker！我更愿意称Docker为一个容器，当然这只是Docker的一个狭义解释，Docker不止是一个容器。Docker包含3个重要概念： 一个，是镜像（Image），镜像是静态的、可以被用户互相分享的文件。我们玩过双系统和虚拟机的人都知道，首先你需要一个.iso镜像，才能安装系统。Docker中的镜像也是这个东西，镜像是静态的，你不能对他操作，只能pull别人的镜像或者push自己的镜像。还有一个，是容器（Container），前面说过，镜像是静态不可操作的，只能被分享和下载，那什么是能被操作的呢？就是容器里！容器可以理解为镜像的动态状态，也就是我们虚拟机中系统装好后的状态，其实这么说是不对的，容器最符合的描述应该是Linux的iso文件的Live CD模式，比如我们玩双系统时都进入过Live CD模式，不安装系统而直接进入系统，很神奇是吧，Docker的容器就是这个概念，只不过更加轻量更加迅速便捷。但是Live CD的害处就是你关机后作出的修改安装的软件全部gg，容器也是一样，一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。 最后，是仓库（Repository）。各位在前面看到我写的pull和push什么的，有没有晕？不知道各位对于git熟悉不熟悉，Docker中的仓库很像git的代码仓库，你可以pull自己之前push到自己仓库的镜像到本地，也可以pull别人push到公共仓库的镜像到自己本地。说白了就是百度云盘，你可以上传（push）自己做好环境的Docker上去，也可以下载（pull）自己云端的镜像到本地。同时，我们知道百度云最大的特点就是分享（你懂的嘿嘿嘿），类比Docker，如果你得到百度云分享链接（别人的镜像名字、标签和别人的用户名），你还可以下载（pull）别人分享的镜像到自己的本地，别人也可以下载（pull）你的镜像，因为Docker仓库都是公共的。当然，每个免费用户有一个名额把自己的一个镜像设为私有，也就是禁止被分享给别人，类比百度云上你自己保存的而没有被生成分享链接的小姐姐。作者：sgyzetrov来源：CSDN原文：https://blog.csdn.net/S_gy_Zetrov/article/details/78161154?utm_source=copy版权声明：本文为博主原创文章，转载请附上博文链接！ 2.安装 dockerbrew cask install没有安装 brew 请先安装 brew3.拉取自己需要的镜像(比如 Oracle)docker pull alexeiled/docker-oracle-xe-11g4.拉取完成后，启动镜像docker run -h &quot;oracle&quot; --name &quot;oracle&quot; -d -p 49160:22 -p 49161:1521 -p 49162:8080 alexeiled/docker-oracle-xe-11g 每运行一次镜像都会启动一个容器,容器删除后，可以通过运行镜像再次获得，但是镜像删除后，就只能重新拉取了-p 49160:22 -p 49161:1521 -p 49162:8080 这一段的意思是把 oracle 容器的1521，22，8080，端口都映射到本机的49160端口 5.命令介绍1.docker ps 查看当前运行的容器 -a 查看所有的容器（包括关闭的）2.docker exec -it eb98bda6646d /bin/bash 进入容器eb98bda6646d这个是上一步查出来的容器 id3.docker stop eb98bda6646d 停止正在运行的容器4.docker start eb98bda6646d 重新启动已经停止的容器5.docker rm eb98bda6646d 删除容器6.docker images 查看所有镜像7.docker rmi alexeiled/docker-oracle-xe-11g 删除 镜像alexeiled/docker-oracle-xe-11g 镜像的名称]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>基础</tag>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven入门使用]]></title>
    <url>%2F2018%2F09%2F25%2FMaven%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言夜空中最亮的星，2018请照亮我前行~ Maven是我们日常开发都会用到的，新年第一天，把看过的Maven基础概念做了整理，作为入门和查阅使用。 正文Maven概念Maven作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现;它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。 Maven不仅是构建工具，还是一个依赖管理工具和项目管理工具，它提供了中央仓库，能帮我自动下载构件。 maven的安装一：因为本人是window系统，所以这里只介绍window下如何安装，在安装Maven之前，先确认已经安装了JDK. image.png 二：接着去Maven官网下载界面下载想要的版本解压到你想要的目录就行 image.png image.png 三：最后设置一下环境变量，将Maven安装配置到操作系统环境中，主要就是配置M2_HOME 和PATH两项，如图 image.png 都搞定后，验证一下，打开doc输入 mvn -v如何得到下面信息就说明配置成功了 image.png maven目录 image.png bin目录：该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。 boot目录:该目录只包含一个文件，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库。 conf目录:该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为，一般情况下，我们更偏向于复制该文件至/.m2/目录下（表示用户目录），然后修改该文件，在用户范围定制Maven的行为。 lib目录:该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如commons-cli-1.2.jar、commons-lang-2.6.jar等等。 Maven常用命令说明mvn clean：表示运行清理操作（会默认把target文件夹中的数据清理）。mvn clean compile：表示先运行清理之后运行编译，会将代码编译到target文件夹中。mvn clean test：运行清理和测试。mvn clean package：运行清理和打包。mvn clean install：运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用。mvn clean deploy：运行清理和发布（发布到私服上面）。 上面的命令大部分都是连写的，大家也可以拆分分别执行，这是活的，看个人喜好以及使用需求，Eclipse Run as对maven项目会提供常用的命令。 设置http代理编辑seeting.xml文件有时候你所在的公司基于安全因素考虑，要求你使用通过安全认证的代理访问因特网。这种情况下，就需要为Maven配置HTTP代理，才能让它正常访问外部仓库，以下载所需要的资源。首先确认自己无法直接访问公共的maven中央仓库，直接运行命令ping repo1.maven.org可以检查网络。如果真的需要代理，先检查一下代理服务器是否畅通。比如现在有一个IP地址为218.14.227.197，端口为3128的代理服务，我们可以运行telnet 218.14.227.197 3128来检测该地址的该端口是否畅通。如果得到出错信息，需要先获取正确的代理服务信息，如果telnet连接正确，则输入ctrl+]，然后q，回车，退出即可。 检查完毕之后，编辑~/.m2/settings.xml文件(如果没有该文件，则复制$M2_HOME/conf/settings.xml)。添加代理配置如下： 1234567891011121314151617181920&lt;settings&gt; ... &lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;my-proxy&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;host&gt;218.14.227.197&lt;/host&gt; &lt;port&gt;3128&lt;/port&gt; &lt;!-- &lt;username&gt;***&lt;/username&gt; &lt;password&gt;***&lt;/password&gt; &lt;nonProxyHosts&gt; repository.mycom.com|*.google.com &lt;/nonProxyHosts&gt; --&gt; &lt;/proxy&gt; &lt;/proxies&gt; ... &lt;/settings&gt; 这段配置十分简单，proxies下可以有多个proxy元素，如果声明了多个proxy元素，则默认情况下第一个被激活的proxy会生效。这里声明了一个id为my-proxy的代理，active的值为true表示激活该代理，protocol表示使用的代理协议，这里是http。当然，最重要的是指定正确的主机名(host元素)和端口(port元素)。上述xml配置中注释掉了username,password,nonProxyHosts几个元素。当代理服务需要认证时，就需要配置username和password。nonProxyHost元素用来指定哪些主机不需要代理，可以使用”|”符号来分隔多个主机名。此外，该配置也支持通配符，如:*.google.com表示所有以google.com结尾的域名访问都不要通过代理。 Maven插件安装，基于IDEA博主现在使用IDEA来开发的，所以这里介绍一下IDEA中如何配置引入我们上面下载好的Maven image.png Maven使用123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tengj&lt;/groupId&gt; &lt;artifactId&gt;springBootDemo1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springBootDemo1&lt;/name&gt;&lt;/project&gt; 代码的第一行是XML头，指定了该xml文档的版本和编码方式。project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素。根元素下的第一个子元素modelVersion指定了当前的POM模型的版本，对于Maven3来说，它只能是4.0.0代码中最重要是包含了groupId,artifactId和version了。这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者jar都是以基于这些基本的坐标进行区分的。 groupId定义了项目属于哪个组，随意命名，比如谷歌公司的myapp项目，就取名为 com.google.myapp artifactId定义了当前Maven项目在组中唯一的ID,比如定义hello-world。 version指定了项目当前的版本0.0.1-SNAPSHOT,SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的。 name元素生命了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name,以方便信息交流 依赖的配置123456789101112131415161718192021&lt;project&gt;...&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;实际项目&lt;/groupId&gt; &lt;artifactId&gt;模块&lt;/artifactId&gt; &lt;version&gt;版本&lt;/version&gt; &lt;type&gt;依赖类型&lt;/type&gt; &lt;scope&gt;依赖范围&lt;/scope&gt; &lt;optional&gt;依赖是否可选&lt;/optional&gt; &lt;!—主要用于排除传递性依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;…&lt;/groupId&gt; &lt;artifactId&gt;…&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependencies&gt;...&lt;/project&gt; 根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有： grounpId、artifactId和version:以来的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。 type:依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar scope:依赖的范围 optional:标记依赖是否可选 exclusions:用来排除传递性依赖 依赖范围依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围： compile:编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。 test: 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。 provided:已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。 runtime:运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。 system:系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如： 1234567&lt;dependency&gt; &lt;groupId&gt;javax.sql&lt;/groupId&gt; &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt; &lt;Version&gt;2.0&lt;/Version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;&lt;/dependency&gt; import:导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。上述除import以外的各种依赖范围与三种classpath的关系如下: image.png 传递性依赖比如一个account-email项目为例，account-email有一个compile范围的spring-code依赖，spring-code有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖 image.png 有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。 依赖范围假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。 image.png 从上图中，我们可以发现这样的规律： 当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致； 当第二直接依赖的范围是test的时候，依赖不会得以传递； 当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided; 当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime. 依赖调解有时候，当传递性依赖造成为题的时候，就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。这就是依赖调解的作用，依赖调解有两大原则： 路径最近者优先比如项目有A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0),X是A的传递性依赖，但是两条依赖路径上有两个版本的X，所以根据第一原则，A-&gt;D-&gt;X(2.0)路径短，所以X(2.0)会被解析使用 第一声明者优先如果路径都一样长的话，第一原则就不行了，比如 A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0),Y(1.0)和Y(2.0)的路径一样，所以这时候根据第二原则，先声明的被解析。 可选依赖 image.png 如图，项目中A依赖B，B依赖于X和Y，如果所有这三个的范围都是compile的话，那么X和Y就是A的compile范围的传递性依赖，但是如果我想X,Y不作为A的传递性依赖，不给他用的话。就需要下面提到的配置可选依赖。 1234567891011121314151617181920&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt; &lt;artifactId&gt;project-b&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/groupId&gt; &lt;version&gt;8.4-701.jdbc3&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 配置也简单，在依赖里面添加 1&lt;optional&gt;true&lt;/optional&gt; 就表示可选依赖了，这样A如果想用X,Y就要直接显示的添加依赖了。 排除依赖有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中spring-boot-starter-web自带了logback这个日志包，我想引入log4j2的，所以我先排除掉logback的依赖包，再引入想要的包就行了 image.png 排除依赖代码结构： 123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 这里注意：声明exclustion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖。 归类依赖有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号 123456789101112131415161718192021&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juven.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;accout-email&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;springframework.version&gt;1.5.6&lt;/springframework.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 如图所示，先通过 123&lt;/properties&gt; 这里定义你先要的版本&lt;/properties&gt; 来定义，然后在下面依赖使用${}来引入你的属性。 仓库这节将介绍仓库的由来、布局、分类、配置、内部工作机制、镜像等概念 仓库的由来在Maven世界中，任何一个依赖、插件或者项目构建的输出，都可以称为构件。得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。 实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。 为了实现重用，项目构建完毕后可生成的构件也可以安装或者部署到仓库中，供其他项目使用。 仓库的布局任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径，这便是Maven的仓库布局方式。该路经与坐标对应关系为groupId/artifactId/version/artifactId-version.packaging。举个例子，比如下面这个分页插件依赖如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 那他对应的仓库的路径就是这样： image.png Maven仓库是基于简单文件系统存储的，我们也理解其存储方式、因此，当遇到一些与仓库相关的问题时，可以很方便的查找相关文件，方便定位问题。 仓库的分类 image.png 本地仓库一般来说，在Maven项目目录下，没有诸如lib/这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。 默认情况下，不管在Window还是Linux下，每个用户在自己用户目录下都有一个路径名为.m2/repository/的仓库目录。如果你想自定义本地仓库目录地址。你可以编辑文件~/.m2/settings.xml，设置localRepository元素的值为想要的仓库地址，例如: 123&lt;settings&gt;&lt;localRepository&gt;D:\java\repository\&lt;/localRepository&gt;&lt;/settings&gt; 这样，该用户的本地仓库地址就被设置成了 D:\java\repository\。需要注意的是，默认情况下，~/.m2/settings.xml文件不存在，用户需要从Maven安装目录复制$M2_HOME/conf/settings.xml文件再进行编辑。 远程仓库-中央仓库由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。 中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM,信息、许可证信息等，每个月这里都会接受全世界Java程序员大概1亿次的访问，它对全世界Java开发者的贡献由此可见一斑。 远程仓库-私服私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。因此，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用。私服的好处： 节省自己的外网速度 加速Maven构建 部署第三方构建 提高稳定性，增强控制 降低中央仓库的负荷 远程仓库的配置在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有，如JBoss Maven仓库。这时，可以在pom.xml中配置该仓库，代码如下： 1234567891011121314151617&lt;!-- 配置远程仓库 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jboss&lt;/id&gt; &lt;name&gt;JBoss Repository&lt;/name&gt; &lt;url&gt;http://repository.jboss.com/maven2/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; repository:在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。 id：仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。 name：仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。 url：指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。 releases和snapshots：用来控制Maven对于发布版构件和快照版构件的下载权限。需要注意的是enabled子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。 layout：元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。基本不会用到Maven1的布局。 其他：对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy。1：元素updatePolicy用来配置Maven从远处仓库检查更新的频率，默认值是daily，表示Maven每天检查一次。其他可用的值包括：never-从不检查更新；always-每次构建都检查更新；interval：X-每隔X分钟检查一次更新（X为任意整数）。2：元素checksumPolicy用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven遇到校验和错误就让构建失败；ignore-使Maven完全忽略校验和错误。 远程仓库的认证大部分的远程仓库不需要认证，但是如果是自己内部使用，为了安全起见，还是要配置认证信息的。配置认证信息和配置远程仓库不同，远程仓库可以直接在pom.xml中配置，但是认证信息必须配置在settings.xml文件中。这是因为pom往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只存在于本机。因此，在settings.xml中配置认证信息更为安全。 123456789101112&lt;settings&gt; 2 ... 3 &lt;!--配置远程仓库认证信息--&gt; 4 &lt;servers&gt; 5 &lt;server&gt; 6 &lt;id&gt;releases&lt;/id&gt; 7 &lt;username&gt;admin&lt;/username&gt; 8 &lt;password&gt;admin123&lt;/password&gt; 9 &lt;/server&gt;10 &lt;/servers&gt;11 ...12 &lt;/settings&gt; 这里除了配置账号密码之外，值关键的就是id了，这个id要跟你在pom.xml里面配置的远程仓库repository的id一致，正是这个id将认证信息与仓库配置联系在了一起。 部署构件至远程仓库我们自己搭建远程仓库的目的就是为了可以方便部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件。这样才能在开发时，供其他对团队成员使用。Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，代码如下： 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;name&gt;public&lt;/name&gt; &lt;url&gt;http://59.50.95.66:8081/nexus/content/repositories/releases&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;name&gt;Snapshots&lt;/name&gt; &lt;url&gt;http://59.50.95.66:8081/nexus/content/repositories/snapshots&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 看代码，从命名上就看的出来区别，repository表示表示发布版本（稳定版本）构件的仓库，snapshotRepository表示快照版本（开发测试版本）的仓库。这两个元素都需要配置id、name和url，id为远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。 配置好了就运行命令mvn clean deploy，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。当前项目是快照还是发布版本是通过 true 这个来区分的。忘记的同学在看看上面的## 远程仓库的配置。 镜像如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。用过Maven的都知道，国外的中央仓库用起来太慢了，所以选择一个国内的镜像就很有必要，我推荐国内的阿里云镜像。阿里云镜像：配置很简单，修改conf文件夹下的settings.xml文件，添加如下镜像配置： 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 上例子中，的值为central,表示该配置为中央库的镜像，任何对于中央仓库的请求都会转至该镜像，用户也可以用同样的方法配置其他仓库的镜像 这里介绍下&lt;mirrorOf&gt;配置的各种选项 &lt;mirrorOf&gt;*&lt;mirrorOf&gt;:匹配所有远程仓库。 &lt;mirrorOf&gt;external:*&lt;mirrorOf&gt;:匹配所有远程仓库，使用localhost的除外，使用file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。 &lt;mirrorOf&gt;repo1,repo2&lt;mirrorOf&gt;:匹配仓库repo1h和repo2，使用逗号分隔多个远程仓库。 &lt;mirrorOf&gt;*,!repo1&lt;mirrorOf&gt;:匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。 需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。 仓库服务搜索这里介绍2个提供仓库服务搜索的地址： Sonatype Nexus：https://repository.sonatype.org/ MVNrepository：http://mvnrepository.com/ ——————— 本文来地址请点击：https://www.jianshu.com/p/41d07cf95482]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>必须掌握</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BigDecimal精度转换]]></title>
    <url>%2F2018%2F09%2F25%2FBigDecimal%E7%B2%BE%E5%BA%A6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[BigDecimal通常在涉及到精确计算的时候会用到，下面是自己多次错误使用BigDecimal的总结。 结论： BigDecimal初始化小数时，尽量用字符串形式，例如new BigDecimal(“0.1”); BigDecimal类型变量比较大小时用compareTo方法，判断变量值是否为0，与BigDecimal.ZERO比较大小。 BigDecimal作除法时，除了要考虑除数是否为0，更要考虑是否能除尽的问题，直接调用BigDecimal divide**(BigDecimal divisor, int scale, int roundingMode)**方法做除法可以避免除不尽的问题。 初始化BigDecimal变量：1234567 //BigDecimal初始化 public static void testBigDecimalinit() &#123; BigDecimal num1 = new BigDecimal(0.1); System.out.println("坑点1：num1="+num1);//坑点1：num1=0.100000000000000005551115123125782702118158340454101562 BigDecimal num2 = new BigDecimal("0.1");System.out.println("正确写法：num2="+num2);//正确写法：num2=0.1 &#125; 结论：尽量用字符串的形式初始化，因为小数在计算机内部根本没法精确表示。 比较大小比较BigDecimal类型的变量和0的大小，用compareTo，不要用equals： 1234567891011121314151617if (num1.compareTo(BigDecimal.ZERO)&gt;0)if (num1.compareTo(BigDecimal.ZERO)&lt;0)if (num1.compareTo(BigDecimal.ZERO)==0) //比较大小 public static void testBigDecimalCompareTo() &#123; BigDecimal num1 = new BigDecimal("0.1"); BigDecimal num2 = new BigDecimal("0.100"); if (!num1.equals(num2)) &#123; System.out.println("坑点1，用equals比较大小，num1="+num1+", num2="+num2+" 【不相等】"); &#125; if (!(num1 == num2)) &#123; System.out.println("坑点2，用==运算符比较大小，num1="+num1+", num2="+num2+" 【不相等】"); &#125; if (num1.compareTo(num2) == 0) &#123; System.out.println("正确比较大小，用compareTo，num1="+num1+", num2="+num2+" 【相等】"); &#125; &#125; 结论：比较大小或者值是否相等，用compareTo方法 BigDecimal除法在出现除不尽的时候，会出现问题，例如1/3的问题： 12345678//BigDecimal除法 public static void testBigDecimalDivide() &#123; BigDecimal num1 = new BigDecimal("1"); //坑点：Exception in thread "main" java.lang.ArithmeticException: Non-terminating decima l expansion; no exact representable decimal result.// System.out.println("坑点写法1："+num1.divide(new BigDecimal("3")));// System.out.println("坑点写法2："+num1.divide(new BigDecimal("3")).setScale(2, BigDecimal.ROUND_DOWN)); System.out.println("正确写法："+num1.divide(new BigDecimal("3"), 2, BigDecimal.ROUND_HALF_DOWN)); &#125; 结论：只有在divide的时候就设置好要精确的小数位数和舍入模式，才能避免出现无法精确表达除不尽的问题。 ——————— 本文来自 h4x0r_007 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/h4x0r_007/article/details/45171141?utm_source=copy]]></content>
      <categories>
        <category>开发中遇到的 bug</category>
      </categories>
      <tags>
        <tag>BigDecimal</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加图片]]></title>
    <url>%2F2018%2F09%2F22%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[配置开启生成博文文件夹选项​ 把主页配置和文件 _config.yml 里的 post_asset_folder: 这个选项的值改为 true 安装插件​ 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件 生成带文件夹的博文​ 运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 引入图片最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 验证查看​ 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是，而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片]]></content>
      <categories>
        <category>Hexo-NexT</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 入门使用]]></title>
    <url>%2F2018%2F09%2F21%2FGit-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[第一步 先初始化 git 仓库 到需要cd到 git 管理的文件下 cd *** 使用 git init 初始化 git 仓库 git init 第二步 在 gitee 或者 github 上建立远程仓库Gitee GitHub 第三步 建立本地和远程的连接git pull origin master --allow-unrelated-histories 第四步 把要提交的东西天剑到暂存区 首先使用 git status 查看暂存区是否有要提交的文件 假设没有文件 则使用 git dd &lt;这个文件的相对路径&gt; 如果要添加全部 则使用 git add . 第五步 提交暂存区的文件到本地 Gitgit commit -m &quot;注释&quot; 第六步 把本地仓库 push 到远程仓库git push -u origin master 这个时候大家会发现它报错了 惊喜吧 别着急 咱们马上说解决方法 错误如下 [rejected] master -> master (fetch first)123456error: failed to push some refs to &apos;https://gitee.com/stardf/Hexo-Next.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. ` 解决方法: 先拉去一下远程仓库 git pull origin master --allow-unrelated-histories 然后再推送到远程仓库 git push origin master 第七步 建立自己的分支为什么要建立自己的分支呢，因为实际操作都不允许直接在 master 主分支上进行提交 只有先到自己的分支 然后合并到主分支才可以 建立自己的本地分支 git checkouut -b &lt;要创建的分支名&gt; 如 git checkout -b dev_test hexo_zmy 这行命令的意思是创建并且切换到这个分支 使用 git branch 查看当前的分支 带 * 就代表目前是那个分支 修改文件提交到自己现在使用的本地分支 git commit -m &quot;&quot; 本地分支推送到远程分支 若是不推送的话 这个分支只会存在你本地 远程仓库也不会出现这个分支的远程分支 git push --set-upstream origin 本地分支名:远程分支名 这行命令执行后 就会先在远程仓库建立一个远程分支 名字就是你的远程分支名 然后把现在使用的本地分支推送到这个远程分支 第八步 把自己的分支合并到主分支 Master 首先切换到 本地Master主分支、 git checkout master 合并别的分支 git merge &lt;被合并的分支名&gt; 这个时候你的本地 master 分支已经成功合并了 hexo_zmy 的分支但是远程分支上还没有所以好 合并后的本地分支需要推送到远程分支 git push origin master 这个时候远程仓库也会出现合并的内容了 第九步 一些技巧和常用的命令一定要注意 一定要注意 一定要注意 在每次提交前先拉取，有冲突解决冲突再提交 再说一些常用的命令 git常用命令： git init //初始化本地git环境 git clone XXX//克隆一份代码到本地仓库 git pull //把远程库的代码更新到工作台 git pull –rebase origin master //强制把远程库的代码跟新到当前分支上面 git fetch //把远程库的代码更新到本地库 git add . //把本地的修改加到stage中 git commit -m ‘comments here’ //把stage中的修改提交到本地库 git push //把本地库的修改提交到远程库中 git branch -r/-a //查看远程分支/全部分支 git checkout master/branch //切换到某个分支 git checkout -b test //新建test分支 git checkout -d test //删除test分支 git merge master //假设当前在test分支上面，把master分支上的修改同步到test分支上 git merge tool //调用merge工具 git stash //把未完成的修改缓存到栈容器中 git stash list //查看所有的缓存 git stash pop //恢复本地分支到缓存状态 git blame someFile //查看某个文件的每一行的修改记录（）谁在什么时候修改的） git status //查看当前分支有哪些修改 git log //查看当前分支上面的日志信息 git diff //查看当前没有add的内容 git diff –cache //查看已经add但是没有commit的内容 git diff HEAD //上面两个内容的合并 git reset –hard HEAD //撤销本地修改 echo $HOME //查看git config的HOME路径 export $HOME=/c/gitconfig //配置git config的HOME路径 团队协作git操作流程： 克隆一个全新的项目，完成新功能并且提交： git clone XXX //克隆代码库 git checkout -b test //新建分支 modify some files //完成修改 git add . //把修改加入stage中 git commit -m ‘’ //提交修改到test分支 review代码 git checkout master //切换到master分支 git pull //更新代码 git checkout test //切换到test分支 git meger master //把master分支的代码merge到test分支 git push origin 分支名//把test分支的代码push到远程库 目前正在test分支上面开发某个功能，但是没有完成。突然一个紧急的bug需要处理 git add . git stash git checkout bugFixBranch git pull –rebase origin master fix the bug git add . git commit -m ‘’ git push git checkout test git stash pop continue new feature’s development git工作流]]></content>
      <categories>
        <category>GIt</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>基础</tag>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象-抽象]]></title>
    <url>%2F2018%2F09%2F21%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象分析与设计的主要任务是？找出类和对象，构建对象模型。 对象模型的主要元素？ 抽象 封装 模块化和层次结构 对象模型的次要元素？ 类型 并发 持久 抽象描述了一个对象的基本特征，可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的角度有关。 抽象关注一个对象的外部视图，用来分离对象的基本行为和实现。我们可以理解为抽象关注接口，即可观察到的行为；而封装则关注这些行为的实现。 面向对象设计的核心问题是对于给定问题找出一组正确的抽象 面向对象设计的核心问题的复杂度取决于抽象的类型和质量 抽象的两个原则 最少承诺原则：对象的接口之提供它的行为 最少惊奇原则：对象捕捉了某个对象的全部行为，不多也不少。并且不提供抽象之外的惊奇效果和副作用。 评判抽象的品质 耦合：模块之间的关联强度应该是比较弱的，既低耦合。 内聚：模块内的各个元素的联系是紧密的，既高内聚。 充分性：类或模块应该记录某个抽象足够多的特征，从而允许有意义的，有效的交互。 完整性：类和模块的接口记录了它的全部特征。 基础性：只有访问该抽象的底层表现形式才能够有效的实现那些操作。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 编程思想 第一次阅读]]></title>
    <url>%2F2018%2F09%2F21%2FJAVA-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[阅读笔记编程语言是什么？是人类用来和机器交互以用来解决现实问题的一种语言！ 几乎所有语言中都有的抽象机制是什么？抽象就是从众多事物中抽取出来他们本质性的特征，而舍弃其非本质的特征]]></content>
      <categories>
        <category>阅读理解</category>
      </categories>
      <tags>
        <tag>抽象</tag>
      </tags>
  </entry>
</search>
