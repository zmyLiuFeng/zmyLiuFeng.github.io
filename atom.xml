<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MYZ BLOG</title>
  
  <subtitle>新的开始！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zmyliufeng.github.io/"/>
  <updated>2018-11-20T06:39:01.639Z</updated>
  <id>https://zmyliufeng.github.io/</id>
  
  <author>
    <name>MYZ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并行与并发</title>
    <link href="https://zmyliufeng.github.io/2018/11/20/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <id>https://zmyliufeng.github.io/2018/11/20/并行与并发/</id>
    <published>2018-11-20T03:55:23.000Z</published>
    <updated>2018-11-20T06:39:01.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><p>并发和并行最开始都是操作系统中的概念，表示的是CPU执行多个任务的方式。这两个概念极容易混淆。</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>1.什么是并行？<br>并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。  (只有在系统有多个 CPU 的时候才会出现真正意义上的并行)<br>多个人同事做多件事</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>1.什么是并发？<br>并发实际就是 cpu 时间片的切换，在单核 CPU 中，CPU同一时间内只能做一件事情，Windown 系统为了让其看起来是“同时做多件事请”，把 CPU 的时间划划分长短基本相同的时间区间，既“时间片”，通过操作系统的管理，把这些时间片进行轮流的分配给各个应用使用，这样，给用户的感觉就是他在同时进行听歌和打游戏，实际上，在操作系统中，CPU 是在听歌进程和游戏进程中来回快速的切换。这个是我们所理解的并发，那么并发的定义到底是什么呢？<br>并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。<br>一个人同事做多件事</p><h2 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h2><p>并发，指的是多个事情，在同一时间段内同时发生了。<br>并行，指的是多个事情，在同一时间点上同时发生了。</p><p>并发的多个任务之间是互相抢占资源的。<br>并行的多个任务之间是不互相抢占资源的、</p><p>只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p><p><img src="15426848725853/15426858536477.jpg" alt=""><br>就像上面这张图，只有一个咖啡机的时候，一台咖啡机其实是在并发被使用的。而有多个咖啡机的时候，多个咖啡机之间才是并行被使用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并行与并发&quot;&gt;&lt;a href=&quot;#并行与并发&quot; class=&quot;headerlink&quot; title=&quot;并行与并发&quot;&gt;&lt;/a&gt;并行与并发&lt;/h1&gt;&lt;p&gt;并发和并行最开始都是操作系统中的概念，表示的是CPU执行多个任务的方式。这两个概念极容易混淆。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="阅读理解" scheme="https://zmyliufeng.github.io/categories/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="线程" scheme="https://zmyliufeng.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mac下Docker的安装使用</title>
    <link href="https://zmyliufeng.github.io/2018/10/17/Mac%E4%B8%8BDocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://zmyliufeng.github.io/2018/10/17/Mac下Docker的安装使用/</id>
    <published>2018-10-17T02:21:23.000Z</published>
    <updated>2018-10-17T02:29:45.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac下Docker的安装使用"><a href="#Mac下Docker的安装使用" class="headerlink" title="Mac下Docker的安装使用"></a><center><em>Mac下Docker的安装使用</em></center></h1><p>1.什么是 docker<br>Docker，可以说是一个终端命令行的虚拟机，但更准确的说法，其实应该是一个虚拟环境。比如，你想要在PC上无缝使用Linux么？那么虚拟机并不是你唯一的出路，你还有Docker！我更愿意称Docker为一个容器，当然这只是Docker的一个狭义解释，Docker不止是一个容器。Docker包含3个重要概念：</p><p>一个，是镜像（Image），镜像是静态的、可以被用户互相分享的文件。我们玩过双系统和虚拟机的人都知道，首先你需要一个.iso镜像，才能安装系统。Docker中的镜像也是这个东西，镜像是静态的，你不能对他操作，只能pull别人的镜像或者push自己的镜像。<br>还有一个，是容器（Container），前面说过，镜像是静态不可操作的，只能被分享和下载，那什么是能被操作的呢？就是容器里！容器可以理解为镜像的动态状态，也就是我们虚拟机中系统装好后的状态，其实这么说是不对的，容器最符合的描述应该是Linux的iso文件的Live CD模式，比如我们玩双系统时都进入过Live CD模式，不安装系统而直接进入系统，很神奇是吧，Docker的容器就是这个概念，只不过更加轻量更加迅速便捷。但是Live CD的害处就是你关机后作出的修改安装的软件全部gg，容器也是一样，一旦被直接推出，之前安装的gcc啊vim啊啥的就会全部gg掉。如果要保存修改，就需要将当前容器封装成一个新的镜像，这样下次启动这个新的镜像后之前作出的修改还都在。</p><h2 id="最后，是仓库（Repository）。各位在前面看到我写的pull和push什么的，有没有晕？不知道各位对于git熟悉不熟悉，Docker中的仓库很像git的代码仓库，你可以pull自己之前push到自己仓库的镜像到本地，也可以pull别人push到公共仓库的镜像到自己本地。说白了就是百度云盘，你可以上传（push）自己做好环境的Docker上去，也可以下载（pull）自己云端的镜像到本地。同时，我们知道百度云最大的特点就是分享（你懂的嘿嘿嘿），类比Docker，如果你得到百度云分享链接（别人的镜像名字、标签和别人的用户名），你还可以下载（pull）别人分享的镜像到自己的本地，别人也可以下载（pull）你的镜像，因为Docker仓库都是公共的。当然，每个免费用户有一个名额把自己的一个镜像设为私有，也就是禁止被分享给别人，类比百度云上你自己保存的而没有被生成分享链接的小姐姐。"><a href="#最后，是仓库（Repository）。各位在前面看到我写的pull和push什么的，有没有晕？不知道各位对于git熟悉不熟悉，Docker中的仓库很像git的代码仓库，你可以pull自己之前push到自己仓库的镜像到本地，也可以pull别人push到公共仓库的镜像到自己本地。说白了就是百度云盘，你可以上传（push）自己做好环境的Docker上去，也可以下载（pull）自己云端的镜像到本地。同时，我们知道百度云最大的特点就是分享（你懂的嘿嘿嘿），类比Docker，如果你得到百度云分享链接（别人的镜像名字、标签和别人的用户名），你还可以下载（pull）别人分享的镜像到自己的本地，别人也可以下载（pull）你的镜像，因为Docker仓库都是公共的。当然，每个免费用户有一个名额把自己的一个镜像设为私有，也就是禁止被分享给别人，类比百度云上你自己保存的而没有被生成分享链接的小姐姐。" class="headerlink" title="最后，是仓库（Repository）。各位在前面看到我写的pull和push什么的，有没有晕？不知道各位对于git熟悉不熟悉，Docker中的仓库很像git的代码仓库，你可以pull自己之前push到自己仓库的镜像到本地，也可以pull别人push到公共仓库的镜像到自己本地。说白了就是百度云盘，你可以上传（push）自己做好环境的Docker上去，也可以下载（pull）自己云端的镜像到本地。同时，我们知道百度云最大的特点就是分享（你懂的嘿嘿嘿），类比Docker，如果你得到百度云分享链接（别人的镜像名字、标签和别人的用户名），你还可以下载（pull）别人分享的镜像到自己的本地，别人也可以下载（pull）你的镜像，因为Docker仓库都是公共的。当然，每个免费用户有一个名额把自己的一个镜像设为私有，也就是禁止被分享给别人，类比百度云上你自己保存的而没有被生成分享链接的小姐姐。"></a>最后，是仓库（Repository）。各位在前面看到我写的pull和push什么的，有没有晕？不知道各位对于git熟悉不熟悉，Docker中的仓库很像git的代码仓库，你可以pull自己之前push到自己仓库的镜像到本地，也可以pull别人push到公共仓库的镜像到自己本地。说白了就是百度云盘，你可以上传（push）自己做好环境的Docker上去，也可以下载（pull）自己云端的镜像到本地。同时，我们知道百度云最大的特点就是分享（你懂的嘿嘿嘿），类比Docker，如果你得到百度云分享链接（别人的镜像名字、标签和别人的用户名），你还可以下载（pull）别人分享的镜像到自己的本地，别人也可以下载（pull）你的镜像，因为Docker仓库都是公共的。当然，每个免费用户有一个名额把自己的一个镜像设为私有，也就是禁止被分享给别人，类比百度云上你自己保存的而没有被生成分享链接的小姐姐。</h2><p>作者：sgyzetrov<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/S_gy_Zetrov/article/details/78161154?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/S_gy_Zetrov/article/details/78161154?utm_source=copy</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p><p><img src="15397412605331.jpg" alt=""></p><p>2.安装 docker<br><code>brew cask install</code><br>没有安装 brew 请先安装 brew<br>3.拉取自己需要的镜像(比如 Oracle)<br><code>docker pull alexeiled/docker-oracle-xe-11g</code><br>4.拉取完成后，启动镜像<br><code>docker run -h &quot;oracle&quot; --name &quot;oracle&quot; -d -p 49160:22 -p 49161:1521 -p 49162:8080 alexeiled/docker-oracle-xe-11g</code></p><h2 id="每运行一次镜像都会启动一个容器-容器删除后，可以通过运行镜像再次获得，但是镜像删除后，就只能重新拉取了"><a href="#每运行一次镜像都会启动一个容器-容器删除后，可以通过运行镜像再次获得，但是镜像删除后，就只能重新拉取了" class="headerlink" title="每运行一次镜像都会启动一个容器,容器删除后，可以通过运行镜像再次获得，但是镜像删除后，就只能重新拉取了"></a><em>每运行一次镜像都会启动一个容器,容器删除后，可以通过运行镜像再次获得，但是镜像删除后，就只能重新拉取了</em></h2><p><strong><em>-p 49160:22 -p 49161:1521 -p 49162:8080 这一段的意思是把 oracle 容器的1521，22，8080，端口都映射到本机的49160端口</em></strong></p><p>5.命令介绍<br>1.<code>docker ps</code> 查看当前运行的容器    -a   查看所有的容器（包括关闭的）<br><img src="15397407289699.jpg" alt="-w575"><br>2.<code>docker exec -it eb98bda6646d /bin/bash</code>  进入容器<br>eb98bda6646d这个是上一步查出来的容器 id<br>3.<code>docker stop eb98bda6646d</code> 停止正在运行的容器<br>4.<code>docker start eb98bda6646d</code> 重新启动已经停止的容器<br>5.<code>docker rm eb98bda6646d</code> 删除容器<br>6.<code>docker images</code> 查看所有镜像<br><img src="15397425751510.jpg" alt="-w573"><br>7.<code>docker rmi alexeiled/docker-oracle-xe-11g</code>   删除 镜像<br>alexeiled/docker-oracle-xe-11g   镜像的名称</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mac下Docker的安装使用&quot;&gt;&lt;a href=&quot;#Mac下Docker的安装使用&quot; class=&quot;headerlink&quot; title=&quot;Mac下Docker的安装使用&quot;&gt;&lt;/a&gt;&lt;center&gt;&lt;em&gt;Mac下Docker的安装使用&lt;/em&gt;&lt;/center&gt;
      
    
    </summary>
    
      <category term="Docker" scheme="https://zmyliufeng.github.io/categories/Docker/"/>
    
    
      <category term="入门" scheme="https://zmyliufeng.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="基础" scheme="https://zmyliufeng.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="实用" scheme="https://zmyliufeng.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门使用</title>
    <link href="https://zmyliufeng.github.io/2018/09/25/Maven%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://zmyliufeng.github.io/2018/09/25/Maven入门使用/</id>
    <published>2018-09-25T09:46:09.000Z</published>
    <updated>2018-10-16T07:31:12.184Z</updated>
    
    <content type="html"><![CDATA[<p><img src="maven.png" alt="img" title="&#39;Maven&#39;"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>夜空中最亮的星，2018请照亮我前行~ Maven是我们日常开发都会用到的，新年第一天，把看过的Maven基础概念做了整理，作为入门和查阅使用。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Maven概念"><a href="#Maven概念" class="headerlink" title="Maven概念"></a>Maven概念</h2><p>Maven作为一个构建工具，不仅能帮我们自动化构建，还能够抽象构建过程，提供构建任务实现;它跨平台，对外提供了一致的操作接口，这一切足以使它成为优秀的、流行的构建工具。</p><p>Maven不仅是构建工具，还是一个依赖管理工具和项目管理工具，它提供了中央仓库，能帮我自动下载构件。</p><h2 id="maven的安装"><a href="#maven的安装" class="headerlink" title="maven的安装"></a>maven的安装</h2><p>一：因为本人是window系统，所以这里只介绍window下如何安装，在安装Maven之前，先确认已经安装了JDK.</p><p><img src="1.png" alt="img"></p><p>image.png</p><p>二：接着去<a href="https://link.jianshu.com/?t=http%3A%2F%2Fmaven.apache.org%2Fdownload.cgi" target="_blank" rel="noopener">Maven官网</a>下载界面下载想要的版本解压到你想要的目录就行</p><p><img src="2.png" alt="img"></p><p>image.png</p><p><img src="3.png" alt="img"></p><p>image.png</p><p>三：最后设置一下环境变量，将Maven安装配置到操作系统环境中，主要就是配置<strong>M2_HOME 和PATH</strong>两项，如图</p><p><img src="4.png" alt="img"></p><p>image.png</p><p>都搞定后，验证一下，打开doc输入 mvn -v如何得到下面信息就说明配置成功了</p><p><img src="5.png" alt="img"></p><p>image.png</p><h2 id="maven目录"><a href="#maven目录" class="headerlink" title="maven目录"></a>maven目录</h2><p><img src="6.png" alt="img"></p><p>image.png</p><ul><li><strong>bin目录</strong>：<br>该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。</li><li><strong>boot目录</strong>:<br>该目录只包含一个文件，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库。</li><li><strong>conf目录</strong>:<br>该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为，一般情况下，我们更偏向于复制该文件至/.m2/目录下（表示用户目录），然后修改该文件，在用户范围定制Maven的行为。</li><li><strong>lib目录</strong>:<br>该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如commons-cli-1.2.jar、commons-lang-2.6.jar等等。</li></ul><h2 id="Maven常用命令说明"><a href="#Maven常用命令说明" class="headerlink" title="Maven常用命令说明"></a>Maven常用命令说明</h2><p><strong>mvn clean：</strong>表示运行清理操作（会默认把target文件夹中的数据清理）。<br><strong>mvn clean compile：</strong>表示先运行清理之后运行编译，会将代码编译到target文件夹中。<br><strong>mvn clean test：</strong>运行清理和测试。<br><strong>mvn clean package：</strong>运行清理和打包。<br><strong>mvn clean install：</strong>运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用。<br><strong>mvn clean deploy：</strong>运行清理和发布（发布到私服上面）。</p><p>上面的命令大部分都是连写的，大家也可以拆分分别执行，这是活的，看个人喜好以及使用需求，Eclipse Run as对maven项目会提供常用的命令。</p><h2 id="设置http代理"><a href="#设置http代理" class="headerlink" title="设置http代理"></a>设置http代理</h2><p>编辑seeting.xml文件<br>有时候你所在的公司基于安全因素考虑，要求你使用通过安全认证的代理访问因特网。这种情况下，就需要为Maven配置HTTP代理，才能让它正常访问外部仓库，以下载所需要的资源。首先确认自己无法直接访问公共的maven中央仓库，直接运行命令ping repo1.maven.org可以检查网络。如果真的需要代理，先检查一下代理服务器是否畅通。比如现在有一个IP地址为218.14.227.197，端口为3128的代理服务，我们可以运行telnet 218.14.227.197 3128来检测该地址的该端口是否畅通。如果得到出错信息，需要先获取正确的代理服务信息，如果telnet连接正确，则输入ctrl+]，然后q，回车，退出即可。</p><p>检查完毕之后，编辑~/.m2/settings.xml文件(如果没有该文件，则复制$M2_HOME/conf/settings.xml)。添加代理配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;  </span><br><span class="line">  ...  </span><br><span class="line">  &lt;proxies&gt;  </span><br><span class="line">    &lt;proxy&gt;  </span><br><span class="line">      &lt;id&gt;my-proxy&lt;/id&gt;  </span><br><span class="line">      &lt;active&gt;true&lt;/active&gt;  </span><br><span class="line">      &lt;protocol&gt;http&lt;/protocol&gt;  </span><br><span class="line">      &lt;host&gt;218.14.227.197&lt;/host&gt;  </span><br><span class="line">      &lt;port&gt;3128&lt;/port&gt;  </span><br><span class="line">      &lt;!--  </span><br><span class="line">        &lt;username&gt;***&lt;/username&gt;  </span><br><span class="line">        &lt;password&gt;***&lt;/password&gt;  </span><br><span class="line">        &lt;nonProxyHosts&gt;  </span><br><span class="line">          repository.mycom.com|*.google.com  </span><br><span class="line">        &lt;/nonProxyHosts&gt;  </span><br><span class="line">      --&gt;  </span><br><span class="line">    &lt;/proxy&gt;  </span><br><span class="line">  &lt;/proxies&gt;  </span><br><span class="line">  ...  </span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>这段配置十分简单，proxies下可以有多个proxy元素，如果声明了多个proxy元素，则默认情况下第一个被激活的proxy会生效。这里声明了一个id为my-proxy的代理，active的值为true表示激活该代理，protocol表示使用的代理协议，这里是http。当然，最重要的是指定正确的主机名(host元素)和端口(port元素)。上述xml配置中注释掉了username,password,nonProxyHosts几个元素。当代理服务需要认证时，就需要配置username和password。nonProxyHost元素用来指定哪些主机不需要代理，可以使用”|”符号来分隔多个主机名。此外，该配置也支持通配符，如:*.google.com表示所有以google.com结尾的域名访问都不要通过代理。</p><h2 id="Maven插件安装，基于IDEA"><a href="#Maven插件安装，基于IDEA" class="headerlink" title="Maven插件安装，基于IDEA"></a>Maven插件安装，基于IDEA</h2><p>博主现在使用IDEA来开发的，所以这里介绍一下IDEA中如何配置引入我们上面下载好的Maven</p><p><img src="7.png" alt="img"></p><p>image.png</p><h2 id="Maven使用"><a href="#Maven使用" class="headerlink" title="Maven使用"></a>Maven使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.tengj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springBootDemo1&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;springBootDemo1&lt;/name&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>代码的第一行是XML头，指定了该xml文档的版本和编码方式。<br>project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素。<br>根元素下的第一个子元素modelVersion指定了当前的POM模型的版本，对于Maven3来说，它只能是4.0.0<br>代码中最重要是包含了groupId,artifactId和version了。这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者jar都是以基于这些基本的坐标进行区分的。</p><p>groupId定义了项目属于哪个组，随意命名，比如谷歌公司的myapp项目，就取名为 com.google.myapp</p><p>artifactId定义了当前Maven项目在组中唯一的ID,比如定义hello-world。</p><p>version指定了项目当前的版本0.0.1-SNAPSHOT,SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的。</p><p>name元素生命了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name,以方便信息交流</p><h2 id="依赖的配置"><a href="#依赖的配置" class="headerlink" title="依赖的配置"></a>依赖的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">...</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;实际项目&lt;/groupId&gt;</span><br><span class="line">　　　　 &lt;artifactId&gt;模块&lt;/artifactId&gt;</span><br><span class="line">　　　　 &lt;version&gt;版本&lt;/version&gt;</span><br><span class="line">　　　　 &lt;type&gt;依赖类型&lt;/type&gt;</span><br><span class="line">　　　　 &lt;scope&gt;依赖范围&lt;/scope&gt;</span><br><span class="line">　　　　 &lt;optional&gt;依赖是否可选&lt;/optional&gt;</span><br><span class="line">　　　　 &lt;!—主要用于排除传递性依赖--&gt;</span><br><span class="line">　　　　 &lt;exclusions&gt;</span><br><span class="line">　　　　     &lt;exclusion&gt;</span><br><span class="line">　　　　　　　    &lt;groupId&gt;…&lt;/groupId&gt;</span><br><span class="line">　　　　　　　　　 &lt;artifactId&gt;…&lt;/artifactId&gt;</span><br><span class="line">　　　　　　　&lt;/exclusion&gt;</span><br><span class="line">　　　　 &lt;/exclusions&gt;</span><br><span class="line">　　&lt;/dependency&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p><ul><li><strong>grounpId、artifactId和version</strong>:以来的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</li><li><strong>type</strong>:依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li><li><strong>scope</strong>:依赖的范围</li><li><strong>optional</strong>:标记依赖是否可选</li><li><strong>exclusions</strong>:用来排除传递性依赖</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</p><ul><li><strong>compile:</strong>编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</li><li><strong>test:</strong> 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。</li><li><strong>provided:</strong>已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。</li><li><strong>runtime:</strong>运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li><li><strong>system:</strong>系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.sql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jdbc-stdext&lt;/artifactId&gt;</span><br><span class="line">    &lt;Version&gt;2.0&lt;/Version&gt;</span><br><span class="line">    &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">    &lt;systemPath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/systemPath&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>import:</strong>导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。<br>上述除import以外的各种依赖范围与三种classpath的关系如下:</li></ul><p><img src="8.png" alt="img"></p><p>image.png</p><h2 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h2><p>比如一个account-email项目为例，account-email有一个compile范围的spring-code依赖，spring-code有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖</p><p><img src="9.png" alt="img"></p><p>image.png</p><p>有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p><h2 id="依赖范围-1"><a href="#依赖范围-1" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。</p><p><img src="10.png" alt="img"></p><p>image.png</p><p>从上图中，我们可以发现这样的规律：</p><ul><li>当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；</li><li>当第二直接依赖的范围是test的时候，依赖不会得以传递；</li><li>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided;</li><li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime.</li></ul><h2 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h2><p>有时候，当传递性依赖造成为题的时候，就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。这就是依赖调解的作用，依赖调解有两大原则：</p><ol><li>路径最近者优先<br>比如项目有A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0),X是A的传递性依赖，但是两条依赖路径上有两个版本的X，所以根据第一原则，A-&gt;D-&gt;X(2.0)路径短，所以X(2.0)会被解析使用</li><li>第一声明者优先<br>如果路径都一样长的话，第一原则就不行了，比如 A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0),Y(1.0)和Y(2.0)的路径一样，所以这时候根据第二原则，先声明的被解析。</li></ol><h2 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h2><p><img src="11.png" alt="img"></p><p>image.png</p><p>如图，项目中A依赖B，B依赖于X和Y，如果所有这三个的范围都是compile的话，那么X和Y就是A的compile范围的传递性依赖，但是如果我想X,Y不作为A的传递性依赖，不给他用的话。就需要下面提到的配置可选依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;  </span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </span><br><span class="line">    &lt;groupId&gt;com.juvenxu.mvnbook&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;project-b&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;  </span><br><span class="line">    &lt;dependencies&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;5.1.10&lt;/version&gt;  </span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;postgresql&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;postgresql&lt;/groupId&gt;  </span><br><span class="line">            &lt;version&gt;8.4-701.jdbc3&lt;/version&gt;  </span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">    &lt;/dependencies&gt;  </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>配置也简单，在依赖里面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br></pre></td></tr></table></figure><p>就表示可选依赖了，这样A如果想用X,Y就要直接显示的添加依赖了。</p><h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中spring-boot-starter-web自带了logback这个日志包，我想引入log4j2的，所以我先排除掉logback的依赖包，再引入想要的包就行了</p><p><img src="14.png" alt="img"></p><p>image.png</p><p>排除依赖代码结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br></pre></td></tr></table></figure><p>这里注意：声明exclustion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖。</p><h2 id="归类依赖"><a href="#归类依赖" class="headerlink" title="归类依赖"></a>归类依赖</h2><p>有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;  </span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </span><br><span class="line">    &lt;groupId&gt;com.juven.mvnbook.account&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;accout-email&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;  </span><br><span class="line">    &lt;properties&gt;  </span><br><span class="line">        &lt;springframework.version&gt;1.5.6&lt;/springframework.version&gt;  </span><br><span class="line">    &lt;/properties&gt;  </span><br><span class="line">    &lt;dependencies&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;   </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;         </span><br><span class="line">    &lt;/dependencies&gt;  </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>如图所示，先通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;/properties&gt;</span><br><span class="line">    这里定义你先要的版本</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>来定义，然后在下面依赖使用${}来引入你的属性。</p><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>这节将介绍仓库的由来、布局、分类、配置、内部工作机制、镜像等概念</p><h2 id="仓库的由来"><a href="#仓库的由来" class="headerlink" title="仓库的由来"></a>仓库的由来</h2><p>在Maven世界中，任何一个依赖、插件或者项目构建的输出，都可以称为构件。得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。</p><p>实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。</p><p>为了实现重用，项目构建完毕后可生成的构件也可以安装或者部署到仓库中，供其他项目使用。</p><h2 id="仓库的布局"><a href="#仓库的布局" class="headerlink" title="仓库的布局"></a>仓库的布局</h2><p>任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径，这便是Maven的仓库布局方式。<br>该路经与坐标对应关系为groupId/artifactId/version/artifactId-version.packaging。<br>举个例子，比如下面这个分页插件依赖如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>那他对应的仓库的路径就是这样：</p><p><img src="12.png" alt="img"></p><p>image.png</p><p>Maven仓库是基于简单文件系统存储的，我们也理解其存储方式、因此，当遇到一些与仓库相关的问题时，可以很方便的查找相关文件，方便定位问题。</p><h2 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h2><p><img src="13.png" alt="img"></p><p>image.png</p><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>一般来说，在Maven项目目录下，没有诸如lib/这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p><p>默认情况下，不管在Window还是Linux下，每个用户在自己用户目录下都有一个路径名为.m2/repository/的仓库目录。<br>如果你想自定义本地仓库目录地址。你可以编辑文件~/.m2/settings.xml，设置localRepository元素的值为想要的仓库地址，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">&lt;localRepository&gt;D:\java\repository\&lt;/localRepository&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>这样，该用户的本地仓库地址就被设置成了 D:\java\repository\。<br>需要注意的是，默认情况下，~/.m2/settings.xml文件不存在，用户需要从Maven安装目录复制$M2_HOME/conf/settings.xml文件再进行编辑。</p><h3 id="远程仓库-中央仓库"><a href="#远程仓库-中央仓库" class="headerlink" title="远程仓库-中央仓库"></a>远程仓库-中央仓库</h3><p>由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。</p><p>中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM,信息、许可证信息等，每个月这里都会接受全世界Java程序员大概1亿次的访问，它对全世界Java开发者的贡献由此可见一斑。</p><h3 id="远程仓库-私服"><a href="#远程仓库-私服" class="headerlink" title="远程仓库-私服"></a>远程仓库-私服</h3><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。因此，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用。<br>私服的好处：</p><ul><li>节省自己的外网速度</li><li>加速Maven构建</li><li>部署第三方构建</li><li>提高稳定性，增强控制</li><li>降低中央仓库的负荷</li></ul><h2 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h2><p>在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有，如JBoss Maven仓库。这时，可以在pom.xml中配置该仓库，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置远程仓库 --&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;jboss&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;JBoss Repository&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://repository.jboss.com/maven2/&lt;/url&gt;</span><br><span class="line">            &lt;releases&gt;</span><br><span class="line">                &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">                &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt;</span><br><span class="line">            &lt;/releases&gt;</span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">            &lt;layout&gt;default&lt;/layout&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>repository:</strong>在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。</li><li><strong>id：</strong>仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。</li><li><strong>name：</strong>仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。</li><li><strong>url：</strong>指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。</li><li><strong>releases和snapshots：</strong>用来控制Maven对于发布版构件和快照版构件的下载权限。需要注意的是<strong>enabled</strong>子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</li><li><strong>layout：</strong>元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。基本不会用到Maven1的布局。</li><li><strong>其他：</strong>对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy。<br>1：元素<strong>updatePolicy</strong>用来配置Maven从远处仓库检查更新的频率，默认值是daily，表示Maven每天检查一次。其他可用的值包括：never-从不检查更新；always-每次构建都检查更新；interval：X-每隔X分钟检查一次更新（X为任意整数）。<br>2：元素<strong>checksumPolicy</strong>用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven遇到校验和错误就让构建失败；ignore-使Maven完全忽略校验和错误。</li></ul><h2 id="远程仓库的认证"><a href="#远程仓库的认证" class="headerlink" title="远程仓库的认证"></a>远程仓库的认证</h2><p>大部分的远程仓库不需要认证，但是如果是自己内部使用，为了安全起见，还是要配置认证信息的。<br>配置认证信息和配置远程仓库不同，远程仓库可以直接在pom.xml中配置，但是认证信息必须配置在settings.xml文件中。这是因为pom往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只存在于本机。因此，在settings.xml中配置认证信息更为安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> 2     ...</span><br><span class="line"> 3     &lt;!--配置远程仓库认证信息--&gt;</span><br><span class="line"> 4     &lt;servers&gt;</span><br><span class="line"> 5         &lt;server&gt;</span><br><span class="line"> 6             &lt;id&gt;releases&lt;/id&gt;</span><br><span class="line"> 7             &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line"> 8             &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line"> 9         &lt;/server&gt;</span><br><span class="line">10     &lt;/servers&gt;</span><br><span class="line">11     ...</span><br><span class="line">12 &lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>这里除了配置账号密码之外，值关键的就是id了，这个id要跟你在pom.xml里面配置的远程仓库repository的id一致，正是这个id将认证信息与仓库配置联系在了一起。</p><h2 id="部署构件至远程仓库"><a href="#部署构件至远程仓库" class="headerlink" title="部署构件至远程仓库"></a>部署构件至远程仓库</h2><p>我们自己搭建远程仓库的目的就是为了可以方便部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件。这样才能在开发时，供其他对团队成员使用。<br>Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;releases&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;public&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://59.50.95.66:8081/nexus/content/repositories/releases&lt;/url&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">        &lt;snapshotRepository&gt;</span><br><span class="line">            &lt;id&gt;snapshots&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Snapshots&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://59.50.95.66:8081/nexus/content/repositories/snapshots&lt;/url&gt;</span><br><span class="line">        &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure><p>看代码，从命名上就看的出来区别，repository表示表示发布版本（稳定版本）构件的仓库，snapshotRepository表示快照版本（开发测试版本）的仓库。这两个元素都需要配置id、name和url，id为远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。</p><p>配置好了就运行命令mvn clean deploy，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。<br>当前项目是快照还是发布版本是通过 <enabled>true</enabled> 这个来区分的。忘记的同学在看看上面的## 远程仓库的配置。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。用过Maven的都知道，国外的中央仓库用起来太慢了，所以选择一个国内的镜像就很有必要，我推荐国内的阿里云镜像。<br>阿里云镜像：配置很简单，修改conf文件夹下的settings.xml文件，添加如下镜像配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">      &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        </span><br><span class="line">    &lt;/mirror&gt;</span><br><span class="line">  &lt;/mirrors&gt;</span><br></pre></td></tr></table></figure><p>上例子中，<mirrorof>的值为central,表示该配置为中央库的镜像，任何对于中央仓库的请求都会转至该镜像，用户也可以用同样的方法配置其他仓库的镜像</mirrorof></p><p>这里介绍下<code>&lt;mirrorOf&gt;</code>配置的各种选项</p><ul><li><code>&lt;mirrorOf&gt;*&lt;mirrorOf&gt;</code>:匹配所有远程仓库。</li><li><code>&lt;mirrorOf&gt;external:*&lt;mirrorOf&gt;</code>:匹配所有远程仓库，使用localhost的除外，使用file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。</li><li><code>&lt;mirrorOf&gt;repo1,repo2&lt;mirrorOf&gt;</code>:匹配仓库repo1h和repo2，使用逗号分隔多个远程仓库。</li><li><code>&lt;mirrorOf&gt;*,!repo1&lt;mirrorOf&gt;</code>:匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。</li></ul><p>需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。</p><h2 id="仓库服务搜索"><a href="#仓库服务搜索" class="headerlink" title="仓库服务搜索"></a>仓库服务搜索</h2><p>这里介绍2个提供仓库服务搜索的地址：</p><ul><li>Sonatype Nexus：<a href="https://link.jianshu.com/?t=https%3A%2F%2Frepository.sonatype.org%2F" target="_blank" rel="noopener">https://repository.sonatype.org/</a></li><li>MVNrepository：<a href="https://link.jianshu.com/?t=http%3A%2F%2Fmvnrepository.com%2F" target="_blank" rel="noopener">http://mvnrepository.com/</a></li></ul><p>  ———————  本文来地址请点击：<a href="https://www.jianshu.com/p/41d07cf95482" target="_blank" rel="noopener">https://www.jianshu.com/p/41d07cf95482</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;maven.png&quot; alt=&quot;img&quot; title=&quot;&amp;#39;Maven&amp;#39;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;夜空中最亮的星
      
    
    </summary>
    
      <category term="Maven" scheme="https://zmyliufeng.github.io/categories/Maven/"/>
    
    
      <category term="入门" scheme="https://zmyliufeng.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="必须掌握" scheme="https://zmyliufeng.github.io/tags/%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1/"/>
    
  </entry>
  
  <entry>
    <title>BigDecimal精度转换</title>
    <link href="https://zmyliufeng.github.io/2018/09/25/BigDecimal%E7%B2%BE%E5%BA%A6%E8%BD%AC%E6%8D%A2/"/>
    <id>https://zmyliufeng.github.io/2018/09/25/BigDecimal精度转换/</id>
    <published>2018-09-25T07:07:07.000Z</published>
    <updated>2018-10-16T07:31:12.174Z</updated>
    
    <content type="html"><![CDATA[<p>BigDecimal通常在涉及到精确计算的时候会用到，下面是自己多次错误使用BigDecimal的总结。</p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><ol><li>BigDecimal初始化小数时，尽量用字符串形式，例如<strong>new BigDecimal(“0.1”)</strong>;</li><li>BigDecimal类型变量比较大小时用<strong>compareTo</strong>方法，判断变量值是否为0，与<strong>BigDecimal.ZERO</strong>比较大小。</li><li>BigDecimal作除法时，除了要考虑除数是否为0，更要考虑是否能除尽的问题，直接调用BigDecimal <strong>divide**</strong>(BigDecimal  divisor, int scale, int roundingMode)**方法做除法可以避免除不尽的问题。</li></ol><h3 id="初始化BigDecimal变量："><a href="#初始化BigDecimal变量：" class="headerlink" title="初始化BigDecimal变量："></a>初始化BigDecimal变量：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//BigDecimal初始化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBigDecimalinit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="number">0.1</span>);</span><br><span class="line">       System.out.println(<span class="string">"坑点1：num1="</span>+num1);<span class="comment">//坑点1：num1=0.100000000000000005551115123125782702118158340454101562</span></span><br><span class="line">BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.1"</span>);</span><br><span class="line">System.out.println(<span class="string">"正确写法：num2="</span>+num2);<span class="comment">//正确写法：num2=0.1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>结论：尽量用<strong>字符串</strong>的形式初始化，因为小数在计算机内部根本没法精确表示。 </p><h3 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h3><p>比较BigDecimal类型的变量和0的大小，用compareTo，不要用equals：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num1.compareTo(BigDecimal.ZERO)&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (num1.compareTo(BigDecimal.ZERO)&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (num1.compareTo(BigDecimal.ZERO)==<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//比较大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBigDecimalCompareTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.1"</span>);</span><br><span class="line">        BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.100"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!num1.equals(num2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"坑点1，用equals比较大小，num1="</span>+num1+<span class="string">", num2="</span>+num2+<span class="string">" 【不相等】"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span> (!(num1 == num2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"坑点2，用==运算符比较大小，num1="</span>+num1+<span class="string">", num2="</span>+num2+<span class="string">" 【不相等】"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num1.compareTo(num2) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"正确比较大小，用compareTo，num1="</span>+num1+<span class="string">", num2="</span>+num2+<span class="string">" 【相等】"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结论：比较大小或者值是否相等，用<strong>compareTo</strong>方法</p><h3 id="BigDecimal除法"><a href="#BigDecimal除法" class="headerlink" title="BigDecimal除法"></a>BigDecimal除法</h3><p>在出现除不尽的时候，会出现问题，例如1/3的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BigDecimal除法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBigDecimalDivide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">//坑点：Exception in thread "main" java.lang.ArithmeticException: Non-terminating decima    l expansion; no exact representable decimal result.</span></span><br><span class="line"><span class="comment">//        System.out.println("坑点写法1："+num1.divide(new BigDecimal("3")));</span></span><br><span class="line"><span class="comment">//        System.out.println("坑点写法2："+num1.divide(new BigDecimal("3")).setScale(2, BigDecimal.ROUND_DOWN));</span></span><br><span class="line">        System.out.println(<span class="string">"正确写法："</span>+num1.divide(<span class="keyword">new</span> BigDecimal(<span class="string">"3"</span>), <span class="number">2</span>, BigDecimal.ROUND_HALF_DOWN));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结论：只有在divide的时候就设置好<strong>要精确的小数位数和舍入模式</strong>，才能避免出现无法精确表达除不尽的问题。</p><p>  ———————  本文来自 h4x0r_007 的CSDN 博客 ，全文地址请点击：<a href="https://blog.csdn.net/h4x0r_007/article/details/45171141?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/h4x0r_007/article/details/45171141?utm_source=copy</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BigDecimal通常在涉及到精确计算的时候会用到，下面是自己多次错误使用BigDecimal的总结。&lt;/p&gt;
&lt;h3 id=&quot;结论：&quot;&gt;&lt;a href=&quot;#结论：&quot; class=&quot;headerlink&quot; title=&quot;结论：&quot;&gt;&lt;/a&gt;结论：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="开发中遇到的 bug" scheme="https://zmyliufeng.github.io/categories/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-bug/"/>
    
    
      <category term="BigDecimal" scheme="https://zmyliufeng.github.io/tags/BigDecimal/"/>
    
      <category term="exception" scheme="https://zmyliufeng.github.io/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加图片</title>
    <link href="https://zmyliufeng.github.io/2018/09/22/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/"/>
    <id>https://zmyliufeng.github.io/2018/09/22/Hexo博客添加图片/</id>
    <published>2018-09-22T02:03:12.000Z</published>
    <updated>2018-10-16T07:31:12.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置开启生成博文文件夹选项"><a href="#配置开启生成博文文件夹选项" class="headerlink" title="配置开启生成博文文件夹选项"></a>配置开启生成博文文件夹选项</h3><p>​    把主页配置和文件 _config.yml 里的 post_asset_folder: 这个选项的值改为 true</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>​    在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件</p><h3 id="生成带文件夹的博文"><a href="#生成带文件夹的博文" class="headerlink" title="生成带文件夹的博文"></a>生成带文件夹的博文</h3><p>​    运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹</p><h3 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h3><p>最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p><p><img src="test.png" alt="test" title="&#39;test&#39;"></p><p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p><h3 id="验证查看"><a href="#验证查看" class="headerlink" title="验证查看"></a>验证查看</h3><p>​    最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是<img src="2017/02/26/xxxx/图片名.jpg">，而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;配置开启生成博文文件夹选项&quot;&gt;&lt;a href=&quot;#配置开启生成博文文件夹选项&quot; class=&quot;headerlink&quot; title=&quot;配置开启生成博文文件夹选项&quot;&gt;&lt;/a&gt;配置开启生成博文文件夹选项&lt;/h3&gt;&lt;p&gt;​    把主页配置和文件 _config.yml 
      
    
    </summary>
    
      <category term="Hexo-NexT" scheme="https://zmyliufeng.github.io/categories/Hexo-NexT/"/>
    
    
      <category term="小技巧" scheme="https://zmyliufeng.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Git 入门使用</title>
    <link href="https://zmyliufeng.github.io/2018/09/21/Git-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://zmyliufeng.github.io/2018/09/21/Git-入门使用/</id>
    <published>2018-09-21T09:57:23.000Z</published>
    <updated>2018-10-16T07:31:12.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一步-先初始化-git-仓库"><a href="#第一步-先初始化-git-仓库" class="headerlink" title="第一步 先初始化 git 仓库"></a>第一步 先初始化 git 仓库</h3><ol><li><p>到需要cd到 git 管理的文件下</p><p><code>cd ***</code></p></li><li><p>使用 git init 初始化 git 仓库</p><p><code>git init</code></p></li></ol><h3 id="第二步-在-gitee-或者-github-上建立远程仓库"><a href="#第二步-在-gitee-或者-github-上建立远程仓库" class="headerlink" title="第二步 在 gitee 或者 github 上建立远程仓库"></a>第二步 在 gitee 或者 github 上建立远程仓库</h3><p><img src="image-20180921180532246.png" alt="image-20180921180532246">Gitee</p><p><img src="image-20180921180609667.png" alt="image-20180921180609667">GitHub</p><h3 id="第三步-建立本地和远程的连接"><a href="#第三步-建立本地和远程的连接" class="headerlink" title="第三步 建立本地和远程的连接"></a>第三步 建立本地和远程的连接</h3><p><code>git pull origin master --allow-unrelated-histories</code></p><h3 id="第四步-把要提交的东西天剑到暂存区"><a href="#第四步-把要提交的东西天剑到暂存区" class="headerlink" title="第四步 把要提交的东西天剑到暂存区"></a>第四步 把要提交的东西天剑到暂存区</h3><ol><li>首先使用 <code>git status</code> 查看暂存区是否有要提交的文件</li><li>假设没有文件  则使用 <code>git dd &lt;这个文件的相对路径&gt;</code>  如果要添加全部 则使用 <code>git add .</code></li></ol><h3 id="第五步-提交暂存区的文件到本地-Git"><a href="#第五步-提交暂存区的文件到本地-Git" class="headerlink" title="第五步 提交暂存区的文件到本地 Git"></a>第五步 提交暂存区的文件到本地 Git</h3><p><code>git commit -m &quot;注释&quot;</code></p><h3 id="第六步-把本地仓库-push-到远程仓库"><a href="#第六步-把本地仓库-push-到远程仓库" class="headerlink" title="第六步 把本地仓库 push 到远程仓库"></a>第六步 把本地仓库 push 到远程仓库</h3><p><code>git push -u origin master</code></p><p>这个时候大家会发现它报错了   惊喜吧  别着急   咱们马上说解决方法</p><p>错误如下</p><figure class="highlight plain"><figcaption><span>[rejected]        master -> master (fetch first)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &apos;https://gitee.com/stardf/Hexo-Next.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure><p><code>`</code></p><p>解决方法:</p><p>先拉去一下远程仓库</p><p><code>git pull origin master --allow-unrelated-histories</code></p><p>然后再推送到远程仓库</p><p>git push origin master</p><h3 id="第七步-建立自己的分支"><a href="#第七步-建立自己的分支" class="headerlink" title="第七步  建立自己的分支"></a>第七步  建立自己的分支</h3><p>为什么要建立自己的分支呢，因为实际操作都不允许直接在 master 主分支上进行提交  只有先到自己的分支  然后合并到主分支才可以</p><ol><li><p>建立自己的本地分支</p><p><code>git checkouut -b &lt;要创建的分支名&gt;</code></p><p> 如 <code>git checkout -b dev_test</code></p><p>   <img src="image-20180921182516519.png" alt="image-20180921182516519"></p><p>   <img src="image-20180921182516519.png" alt="image-20180921182516519">hexo_zmy</p><p>这行命令的意思是创建并且切换到这个分支</p><p>使用 <code>git branch</code> 查看当前的分支</p><p><img src="image-20180921182645722.png" alt="image-20180921182645722"></p><p>带 * 就代表目前是那个分支</p></li><li><p>修改文件提交到自己现在使用的本地分支</p><p><code>git commit -m &quot;&quot;</code></p></li><li><p>本地分支推送到远程分支</p><p>若是不推送的话  这个分支只会存在你本地  远程仓库也不会出现这个分支的远程分支</p><p><code>git push --set-upstream origin 本地分支名:远程分支名</code></p><p>这行命令执行后  就会先在远程仓库建立一个远程分支  名字就是你的远程分支名   然后把现在使用的本地分支推送到这个远程分支</p><p><img src="image-20180921183331819.png" alt="image-20180921183331819"></p></li></ol><h3 id="第八步-把自己的分支合并到主分支-Master"><a href="#第八步-把自己的分支合并到主分支-Master" class="headerlink" title="第八步 把自己的分支合并到主分支 Master"></a>第八步 把自己的分支合并到主分支 Master</h3><ol><li><p>首先切换到 本地Master主分支、</p><p><code>git checkout master</code></p><p><img src="image-20180921183818158.png" alt="image-20180921183818158"></p></li><li><p>合并别的分支</p><p><code>git merge &lt;被合并的分支名&gt;</code></p><p> <img src="image-20180921184130428.png" alt="image-20180921184130428"></p><p>这个时候你的本地 master 分支已经成功合并了 hexo_zmy 的分支但是远程分支上还没有所以好 合并后的本地分支需要推送到远程分支</p><p><code>git push origin master</code></p><p><img src="image-20180921184415593.png" alt="image-20180921184415593"></p><p>这个时候远程仓库也会出现合并的内容了</p></li></ol><h3 id="第九步-一些技巧和常用的命令"><a href="#第九步-一些技巧和常用的命令" class="headerlink" title="第九步  一些技巧和常用的命令"></a>第九步  一些技巧和常用的命令</h3><p>一定要注意 一定要注意 一定要注意    </p><p><strong>在每次提交前先拉取，有冲突解决冲突再提交</strong></p><p>再说一些常用的命令</p><p><strong>git常用命令：</strong></p><blockquote><ul><li>git init //初始化本地git环境</li><li>git clone XXX//克隆一份代码到本地仓库</li><li>git pull //把远程库的代码更新到工作台</li><li>git pull –rebase origin master //强制把远程库的代码跟新到当前分支上面</li><li>git fetch //把远程库的代码更新到本地库</li><li>git add . //把本地的修改加到stage中</li><li>git commit -m ‘comments here’ //把stage中的修改提交到本地库</li><li>git push //把本地库的修改提交到远程库中</li><li>git branch -r/-a //查看远程分支/全部分支</li><li>git checkout master/branch //切换到某个分支</li><li>git checkout -b test //新建test分支</li><li>git checkout -d test //删除test分支</li><li>git merge master //假设当前在test分支上面，把master分支上的修改同步到test分支上</li><li>git merge tool //调用merge工具</li><li>git stash //把未完成的修改缓存到栈容器中</li><li>git stash list //查看所有的缓存</li><li>git stash pop //恢复本地分支到缓存状态</li><li>git blame someFile //查看某个文件的每一行的修改记录（）谁在什么时候修改的）</li><li>git status //查看当前分支有哪些修改</li><li>git log //查看当前分支上面的日志信息</li><li>git diff //查看当前没有add的内容</li><li>git diff –cache //查看已经add但是没有commit的内容</li><li>git diff HEAD //上面两个内容的合并</li><li>git reset –hard HEAD //撤销本地修改</li><li>echo $HOME //查看git config的HOME路径</li><li>export $HOME=/c/gitconfig //配置git config的HOME路径</li></ul></blockquote><p><strong>团队协作git操作流程：</strong></p><ul><li>克隆一个全新的项目，完成新功能并且提交：</li></ul><blockquote><ol><li>git clone XXX //克隆代码库</li><li>git checkout -b test //新建分支</li><li>modify some files //完成修改</li><li>git add . //把修改加入stage中</li><li>git commit -m ‘’ //提交修改到test分支</li><li>review代码</li><li>git checkout master //切换到master分支</li><li>git pull //更新代码</li><li>git checkout test //切换到test分支</li><li>git meger master //把master分支的代码merge到test分支</li><li>git push origin 分支名//把test分支的代码push到远程库</li></ol></blockquote><ul><li>目前正在test分支上面开发某个功能，但是没有完成。突然一个紧急的bug需要处理</li></ul><blockquote><ol><li>git add .</li><li>git stash</li><li>git checkout bugFixBranch</li><li>git pull –rebase origin master</li><li>fix the bug</li><li>git add .</li><li>git commit -m ‘’</li><li>git push</li><li>git checkout test</li><li>git stash pop</li><li>continue new feature’s development</li></ol></blockquote><ul><li>git工作流</li></ul><blockquote><p><img src="image-20180921185102438.png" alt="image-20180921185102438"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一步-先初始化-git-仓库&quot;&gt;&lt;a href=&quot;#第一步-先初始化-git-仓库&quot; class=&quot;headerlink&quot; title=&quot;第一步 先初始化 git 仓库&quot;&gt;&lt;/a&gt;第一步 先初始化 git 仓库&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;到需要cd到 gi
      
    
    </summary>
    
      <category term="GIt" scheme="https://zmyliufeng.github.io/categories/GIt/"/>
    
    
      <category term="入门" scheme="https://zmyliufeng.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="基础" scheme="https://zmyliufeng.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="实用" scheme="https://zmyliufeng.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>面向对象-抽象</title>
    <link href="https://zmyliufeng.github.io/2018/09/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1/"/>
    <id>https://zmyliufeng.github.io/2018/09/21/面向对象-抽象/</id>
    <published>2018-09-21T02:25:01.000Z</published>
    <updated>2018-10-16T07:31:12.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象分析与设计的主要任务是？"><a href="#面向对象分析与设计的主要任务是？" class="headerlink" title="面向对象分析与设计的主要任务是？"></a>面向对象分析与设计的主要任务是？</h2><p>找出类和对象，构建对象模型。</p><h3 id="对象模型的主要元素？"><a href="#对象模型的主要元素？" class="headerlink" title="对象模型的主要元素？"></a>对象模型的主要元素？</h3><ul><li>抽象</li><li>封装</li><li>模块化和层次结构</li></ul><h3 id="对象模型的次要元素？"><a href="#对象模型的次要元素？" class="headerlink" title="对象模型的次要元素？"></a>对象模型的次要元素？</h3><ul><li>类型</li><li>并发</li><li>持久</li></ul><p>抽象描述了一个对象的基本特征，可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的角度有关。</p><hr><p>抽象关注一个对象的外部视图，用来分离对象的基本行为和实现。我们可以理解为抽象关注接口，即可观察到的行为；而封装则关注这些行为的实现。</p><hr><p><strong>面向对象设计的核心问题是对于给定问题找出一组正确的抽象</strong></p><p><strong>面向对象设计的核心问题的复杂度取决于抽象的类型和质量</strong></p><h3 id="抽象的两个原则"><a href="#抽象的两个原则" class="headerlink" title="抽象的两个原则"></a>抽象的两个原则</h3><ul><li>最少承诺原则：对象的接口之提供它的行为</li><li>最少惊奇原则：对象捕捉了某个对象的全部行为，不多也不少。并且不提供抽象之外的惊奇效果和副作用。</li></ul><h3 id="评判抽象的品质"><a href="#评判抽象的品质" class="headerlink" title="评判抽象的品质"></a>评判抽象的品质</h3><ul><li>耦合：模块之间的关联强度应该是比较弱的，既低耦合。</li><li>内聚：模块内的各个元素的联系是紧密的，既高内聚。</li><li>充分性：类或模块应该记录某个抽象足够多的特征，从而允许有意义的，有效的交互。</li><li>完整性：类和模块的接口记录了它的全部特征。</li><li>基础性：只有访问该抽象的底层表现形式才能够有效的实现那些操作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象分析与设计的主要任务是？&quot;&gt;&lt;a href=&quot;#面向对象分析与设计的主要任务是？&quot; class=&quot;headerlink&quot; title=&quot;面向对象分析与设计的主要任务是？&quot;&gt;&lt;/a&gt;面向对象分析与设计的主要任务是？&lt;/h2&gt;&lt;p&gt;找出类和对象，构建对象模型。
      
    
    </summary>
    
      <category term="JAVA" scheme="https://zmyliufeng.github.io/categories/JAVA/"/>
    
    
      <category term="面向对象" scheme="https://zmyliufeng.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="模型" scheme="https://zmyliufeng.github.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 编程思想 第一次阅读</title>
    <link href="https://zmyliufeng.github.io/2018/09/21/JAVA-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%98%85%E8%AF%BB/"/>
    <id>https://zmyliufeng.github.io/2018/09/21/JAVA-编程思想-第一次阅读/</id>
    <published>2018-09-21T01:38:23.000Z</published>
    <updated>2018-10-16T07:31:12.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><h2 id="编程语言是什么？"><a href="#编程语言是什么？" class="headerlink" title="编程语言是什么？"></a>编程语言是什么？</h2><p>是人类用来和机器交互以用来解决现实问题的一种语言！</p><h2 id="几乎所有语言中都有的抽象机制是什么？"><a href="#几乎所有语言中都有的抽象机制是什么？" class="headerlink" title="几乎所有语言中都有的抽象机制是什么？"></a>几乎所有语言中都有的抽象机制是什么？</h2><p>抽象就是从众多事物中抽取出来他们本质性的特征，而舍弃其非本质的特征</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阅读笔记&quot;&gt;&lt;a href=&quot;#阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记&quot;&gt;&lt;/a&gt;阅读笔记&lt;/h1&gt;&lt;h2 id=&quot;编程语言是什么？&quot;&gt;&lt;a href=&quot;#编程语言是什么？&quot; class=&quot;headerlink&quot; title=&quot;编
      
    
    </summary>
    
      <category term="阅读理解" scheme="https://zmyliufeng.github.io/categories/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="抽象" scheme="https://zmyliufeng.github.io/tags/%E6%8A%BD%E8%B1%A1/"/>
    
  </entry>
  
</feed>
